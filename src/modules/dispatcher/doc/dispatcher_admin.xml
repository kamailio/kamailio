<?xml version="1.0" encoding='ISO-8859-1'?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
"http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd" [
 
<!-- Include general documentation entities -->
<!ENTITY % docentities SYSTEM "../../../../doc/docbook/entities.xml">
%docentities;

<!ENTITY % xinclude SYSTEM "http://www.docbook.org/xml/4.4/xinclude.mod" >
%xinclude;

]>
<!-- Module User's Guide -->

<chapter xmlns:xi="http://www.w3.org/2001/XInclude">

	<title>&adminguide;</title>

	<section>
	<title>Overview</title>
	<para>
		This module offers SIP load balancer functionality and it can be
		used as SIP traffic dispatcher. There are many load balancing and
		traffic dispatching algorithms that you can choose from, for example:
		round-robin, weight based load balancing, call load distribution,
		and hashing over SIP message attributes.
	</para>
	<para>
		The module can be used as a stateless load balancer; it does not
		depend on any call state tracking module. It requires the TM module if
		you enable auto-discovery of active/inactive gateways.
	</para>
	<para>
		It is very lightweight, therefore suitable for handling heavy SIP
		traffic. As the module has a small footprint and the ability to load
		balancing rules from a plain text file, it is suitable for embedded systems.
	</para>
	</section>
	<section>
	<title>Dependencies</title>
	<section>
		<title>&kamailio; modules</title>
		<para>
		The following modules must be loaded before this module:
			<itemizedlist>
			<listitem>
			<para>
				<emphasis>TM - only if active recovery of failed hosts
					is required</emphasis>.
			</para>
			</listitem>
			<listitem>
			<para>
				<emphasis>database engine - only if you want to load
					balancing routes from database instead of plain text file.
				</emphasis>.
			</para>
			</listitem>
			</itemizedlist>
		</para>
	</section>
	<section>
		<title>External libraries or applications</title>
		<para>
		The following libraries or applications must be installed before
		running &kamailio; with this module:
			<itemizedlist>
			<listitem>
			<para>
				<emphasis>none</emphasis>.
			</para>
			</listitem>
			</itemizedlist>
		</para>
	</section>
	</section>

	<section>
	<title>Parameters</title>
	<section id="dispatcher.p.list_file">
		<title><varname>list_file</varname> (string)</title>
		<para>
		Path to the file with destination sets (destination groups).
		</para>
		<para>
		<emphasis>
			Default value is <quote>/etc/kamailio/dispatcher.list</quote> or
			<quote>/usr/local/etc/kamailio/dispatcher.list</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set the <quote>list_file</quote> parameter</title>
		<programlisting format="linespecific">
...
modparam("dispatcher", "list_file", "/run/kamailio/dispatcher.list")
...
</programlisting>
		</example>
	</section>

	<section id="dispatcher.p.db_url">
		<title><varname>db_url</varname> (string)</title>
		<para>
		If you want to load the list of gateways from the database you must set
		this parameter.
		</para>
		<para>
		<emphasis>
			Default value is <quote>NULL</quote> (disable DB support).
		</emphasis>
		</para>
		<example>
		<title>Set <quote>db_url</quote> parameter</title>
		<programlisting format="linespecific">
...
modparam("dispatcher", "db_url", "mysql://user:passwd@localhost/database")
...
</programlisting>
		</example>
	</section>

	<section id="dispatcher.p.table_name">
		<title><varname>table_name</varname> (string)</title>
		<para>
		If you want to load the list of gateways from the database you must set
		this parameter as the database name.
		</para>
		<para>
		<emphasis>
			Default value is <quote>dispatcher</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set <quote>table_name</quote> parameter</title>
		<programlisting format="linespecific">
...
modparam("dispatcher", "table_name", "my_dispatcher")
...
</programlisting>
		</example>
	</section>

	<section id="dispatcher.p.setid_col">
		<title><varname>setid_col</varname> (string)</title>
		<para>
			The column's name in the database storing the gateway's set (group)
			id.
		</para>
		<para>
		<emphasis>
			Default value is <quote>setid</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set <quote>setid_col</quote> parameter</title>
		<programlisting format="linespecific">
...
modparam("dispatcher", "setid_col", "groupid")
...
</programlisting>
		</example>
	</section>

	<section id="dispatcher.p.destination_col">
		<title><varname>destination_col</varname> (string)</title>
		<para>
			The column's name in the database storing the destination
			sip URI.
		</para>
		<para>
		<emphasis>
			Default value is <quote>destination</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set <quote>destination_col</quote> parameter</title>
		<programlisting format="linespecific">
...
modparam("dispatcher", "destination_col", "uri")
...
</programlisting>
		</example>
	</section>

	<section id="dispatcher.p.flags_col">
		<title><varname>flags_col</varname> (string)</title>
		<para>
			The column's name in the database storing the flags for
			the destination URI.
		</para>
		<para>
		<emphasis>
			Default value is <quote>flags</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set <quote>flags_col</quote> parameter</title>
		<programlisting format="linespecific">
...
modparam("dispatcher", "flags_col", "dstflags")
...
</programlisting>
		</example>
	</section>

	<section id="dispatcher.p.priority_col">
		<title><varname>priority_col</varname> (string)</title>
		<para>
			The column's name in the database storing the priority for
			destination URI.
		</para>
		<para>
		<emphasis>
			Default value is <quote>priority</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set <quote>priority_col</quote> parameter</title>
		<programlisting format="linespecific">
...
modparam("dispatcher", "priority_col", "dstpriority")
...
</programlisting>
		</example>
	</section>

	<section id="dispatcher.p.attrs_col">
		<title><varname>attrs_col</varname> (string)</title>
		<para>
			The column's name in the database storing the attributes for
			destination URI.
		</para>
		<para>
		<emphasis>
			Default value is <quote>attrs</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set <quote>attrs_col</quote> parameter</title>
		<programlisting format="linespecific">
...
modparam("dispatcher", "attrs_col", "dstattrs")
...
</programlisting>
		</example>
	</section>

	<section id="dispatcher.p.force_dst">
		<title><varname>force_dst</varname> (int)</title>
		<para>
		If set to 1, force overwriting of destination address (outbound proxy)
		when that is already set. If set to 0, will return error when the
		destination address is already set.
		</para>
		<para>
		<emphasis>
			Default value is <quote>1</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set the <quote>force_dst</quote> parameter</title>
<programlisting format="linespecific">
...
modparam("dispatcher", "force_dst", 1)
...
</programlisting>
		</example>
	</section>
	<section id="dispatcher.p.flags">
		<title><varname>flags</varname> (int)</title>
		<para>
		Various flags that affect dispatcher's behaviour. The flags are defined
		as a bitmask on an integer value.
		If flag 1 is set only the username
		part of the URI will be used when computing an URI based hash.
		If no flags are set the username, hostname and port will be used.
		The port is used only if different from 5060 (normal sip URI) or 5061
		(in the sips: case).
		</para>
		<para>
		If flag 2 is set, then failover support is enabled. The functions
		exported by the module will store the rest of addresses from the
		destination set in XAPVs, and use these XAVPs to try next address if
		the current-tried destination fails.
		</para>
		<para>
		<emphasis>
			Default value is <quote>0</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set the <quote>flags</quote> parameter</title>
<programlisting format="linespecific">
...
modparam("dispatcher", "flags", 3)
...
</programlisting>
		</example>
	</section>
	<section id="dispatcher.p.use_default">
		<title><varname>use_default</varname> (int)</title>
		<para>
		If the parameter is set to 1, the last address in destination set
		is used as a final option to send the request to. For example, it is useful
		when wanting to send the call to an announcement server saying:
		"the gateways are full, try later".
		</para>
		<para>
		<emphasis>
			Default value is <quote>0</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set the <quote>use_default</quote> parameter</title>
<programlisting format="linespecific">
...
modparam("dispatcher", "use_default", 1)
...
</programlisting>
		</example>
	</section>
	<section id="dispatcher.p.xavp_dst">
		<title><varname>xavp_dst</varname> (str)</title>
		<para>
		The name of the XAVP which will hold the list with addresses and
		associated properties, in the order they have been selected by the
		chosen algorithm. If use_default is 1, the values of last XAVP correspond
		to the last address in destination set. In case of using dispatcher.list file,
		you have to set the priority field for each destination to ensure a particular order there.
		The first XAVP is the current selected destination. All the other addresses
		from the destination set will be added in the XAVP list to be able to implement serial forking.
		</para>
		<note>
		<para>
		You must set this parameter if you want to do load balancing fail over.
		</para>
		</note>
		<para>
		<emphasis>
			Default value is <quote>_dsdst_</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set the <quote>xavp_dst</quote> parameter</title>
<programlisting format="linespecific">
...
modparam("dispatcher", "xavp_dst", "_dsdst_")
...
</programlisting>
		</example>
	</section>
	<section id="dispatcher.p.xavp_dst_mode">
		<title><varname>xavp_dst_mode</varname> (int)</title>
		<para>
		Control what fields are added to the XAVP specified by xavp_dst
		parameter.
		</para>
		<para>
		The addeded fields are:
		<itemizedlist>
					<listitem>
						<para>grp - the set id (group id).</para>
					</listitem>
					<listitem>
						<para>uri - the URI address.</para>
					</listitem>
					<listitem>
						<para>sock - the socket pointer.</para>
					</listitem>
					<listitem>
						<para>socket - the socket string - it is added only if xavp_dst_mode has
							bit 2 set (value 2).</para>
					</listitem>
					<listitem>
						<para>sockname - the sockname string - it is added only if xavp_dst_mode
							has bit 3 set (value 3).</para>
					</listitem>
					<listitem>
						<para>dstid - the destination unique id (in case of call load distribution
							algorithm).</para>
					</listitem>
					<listitem>
						<para>attrs - the attributes - they are added if xavp_dst_mode does not
							have the bit 1 set (value 1).</para>
					</listitem>
				</itemizedlist>
		</para>
		<para>
		<emphasis>
			Default value is <quote>0</quote> (add all fields).
		</emphasis>
		</para>
		<example>
		<title>Set the <quote>xavp_dst_mode</quote> parameter</title>
<programlisting format="linespecific">
...
    modparam("dispatcher", "xavp_dst_mode", 1)
...
    modparam("dispatcher", "xavp_dst_mode", 2)
...
</programlisting>
		</example>
	</section>
	<section id="dispatcher.p.xavp_ctx">
		<title><varname>xavp_ctx</varname> (str)</title>
		<para>
		The name of the XAVP which will hold some attributes specific to
		dispatcher routing context. The XAVP can hold the next fields: cnt -
		the number of addresses selected for routing.
		</para>
		<para>
		<emphasis>
			Default value is <quote>_dsctx_</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set the <quote>xavp_ctx</quote> parameter</title>
<programlisting format="linespecific">
...
modparam("dispatcher", "xavp_ctx", "_dsctx_")
...
</programlisting>
		</example>
	</section>
	<section id="dispatcher.p.xavp_ctx_mode">
		<title><varname>xavp_ctx_mode</varname> (int)</title>
		<para>
		Control what fields are added to the XAVP specified by xavp_ctx
		parameter. The cnt field is added if xavp_cnt_mode does not have the
		bit 1 set.
		</para>
		<para>
		<emphasis>
			Default value is <quote>0</quote> (add all fields).
		</emphasis>
		</para>
		<example>
		<title>Set the <quote>xavp_ctx_mode</quote> parameter</title>
<programlisting format="linespecific">
...
modparam("dispatcher", "xavp_ctx_mode", 1)
...
</programlisting>
		</example>
	</section>
	<section id="dispatcher.p.hash_pvar">
		<title><varname>hash_pvar</varname> (str)</title>
		<para>
		String with PVs used for the hashing algorithm 7.
		</para>
		<note>
		<para>
		You must set this parameter if you want do hashing over custom message
		parts.
		</para>
		</note>
		<para>
		<emphasis>
			Default value is <quote>null</quote> - disabled.
		</emphasis>
		</para>
		<example>
		<title>Use $avp(hash) for hashing:</title>
<programlisting format="linespecific">
...
modparam("dispatcher", "hash_pvar", "$avp(hash)")
...
</programlisting>
		</example>
		<example>
		<title>Use combination of PVs for hashing:</title>
<programlisting format="linespecific">
...
modparam("dispatcher", "hash_pvar", "hash the $fU@$ci")
...
</programlisting>
		</example>
	</section>
	<section id="dispatcher.p.setid_pvname">
		<title><varname>setid_pvname</varname> (str)</title>
		<para>
		The name of the PV where to store the set ID (group ID) when calling
		ds_is_from_list() with no parameter.
		</para>
		<para>
		<emphasis>
			Default value is <quote>null</quote> - don't set PV.
		</emphasis>
		</para>
		<example>
		<title>Set the <quote>setid_pvname</quote> parameter</title>
<programlisting format="linespecific">
...
modparam("dispatcher", "setid_pvname", "$var(setid)")
...
</programlisting>
		</example>
	</section>
	<section id="dispatcher.p.attrs_pvname">
		<title><varname>attrs_pvname</varname> (str)</title>
		<para>
		The name of the PV where to store the attributes of matching address
		when calling ds_is_from_list().
		</para>
		<para>
		<emphasis>
			Default value is <quote>null</quote> - don't set PV.
		</emphasis>
		</para>
		<example>
		<title>Set the <quote>attrs_pvname</quote> parameter</title>
<programlisting format="linespecific">
...
modparam("dispatcher", "attrs_pvname", "$var(attrs)")
...
</programlisting>
		</example>
	</section>
	<section id="dispatcher.p.ds_ping_method">
		<title><varname>ds_ping_method</varname> (string)</title>
		<para>
		With this method you can define, with which method you want to probe the gateways.
		Pinging gateways feature depends on ds_ping_interval parameter.
		</para>
		<para>
		<emphasis>
			Default value is <quote>OPTIONS</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set the <quote>ds_ping_method</quote> parameter</title>
<programlisting format="linespecific">
...
modparam("dispatcher", "ds_ping_method", "INFO")
...
</programlisting>
		</example>
	</section>
	<section id="dispatcher.p.ds_ping_from">
		<title><varname>ds_ping_from</varname> (string)</title>
		<para>
		With this Method you can define the "From:"-Line for the request, sent to the failed gateways.
		This method is only available, if compiled with the probing of failed gateways enabled.
		</para>
		<para>
		<emphasis>
			Default value is <quote>sip:dispatcher@localhost</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set the <quote>ds_ping_from</quote> parameter</title>
<programlisting format="linespecific">
...
modparam("dispatcher", "ds_ping_from", "sip:proxy@sip.somehost.com")
...
</programlisting>
		</example>
	</section>

	<section id="dispatcher.p.ds_ping_interval">
		<title><varname>ds_ping_interval</varname> (int)</title>
		<para>
		With this parameter you can define the interval for sending a request
		to a gateway marked as inactive upon a failed request routing to it.
		This parameter is only used, when the TM-Module is loaded.
		If set to <quote>0</quote>, the pinging of inactive gateway is disabled.
		</para>
		<para>
		<emphasis>
			Default value is <quote>0</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set the <quote>ds_ping_interval</quote> parameter</title>
<programlisting format="linespecific">
...
modparam("dispatcher", "ds_ping_interval", 30)
...
</programlisting>
		</example>
	</section>

	<section id="dispatcher.p.ds_probing_threshold">
		<title><varname>ds_probing_threshold</varname> (int)</title>
		<para>
		If you want to set a gateway into inactive mode, there can be
		a specific number of failed requests until it will change from "active"
		to "inactive". It is using the state "trying", that allows selection
		of gateway but indicates there was a failure previously with the
		gateway. The number of attempts can be set with this parameter.
		This parameter can be modified via ser config framework.
		</para>
		<para>
		<emphasis>
		Default value is <quote>1</quote> (set inactive with first failure).
		</emphasis>
		</para>
		<example>
		<title>Set the <quote>ds_probing_threshold</quote> parameter</title>
<programlisting format="linespecific">
...
modparam("dispatcher", "ds_probing_threshold", 10)
...
</programlisting>
		</example>
	</section>
	<section id="dispatcher.p.ds_inactive_threshold">
                <title><varname>ds_inactive_threshold</varname> (int)</title>
                <para>
                If you want to set a gateway into active mode (after being inactive), there can be
                a specific number of successful requests until it will change from "inactive"
                to "active". The number of attempts can be set with this parameter.
                This parameter can be modified via ser config framework.
                </para>
                <para>
                <emphasis>
                Default value is <quote>1</quote> (set active with first success).
                </emphasis>
                </para>
                <example>
                <title>Set the <quote>ds_inactive_threshold</quote> parameter</title>
<programlisting format="linespecific">
...
modparam("dispatcher", "ds_inactive_threshold", 10)
...
</programlisting>
                </example>
	</section>
	<section id="dispatcher.p.ds_ping_reply_codes">
		<title><varname>ds_ping_reply_codes</varname> (string)</title>
		<para>
			This parameter defines the valid response codes, which are accepted
			as a valid reply to the PING-Method. It is a list separated by
			colons, where you may define either a single code (e.g. "code=202"
			would accept 202 as an additional, valid response) or a class of
			responses, you want to accept (e.g. "class=2" would accept
			everything from 200 to 299 as valid response). This parameter can
			be modified via config framework.
		</para>
		<para>
			Please note that the response codes the module accepts as valid reply to the
			PING-Method are not only the ones generated from the remote servers, but also those
			that are generated locally. E.g.: setting code=408 or class=400 will never set
			a backend down even if it is, because internally the Kamailio transaction layer
			generates a 408 in the case of no response from the remote server, and this
			internal code 408 is accepted as valid value.
		</para>
		<para>
		<emphasis>
			Default value is <quote></quote> (only 200 OK is accepted).
		</emphasis>
		</para>
		<example>
		<title>Set the <quote>ds_ping_reply_codes</quote> parameter</title>
<programlisting format="linespecific">
...
modparam("dispatcher", "ds_ping_reply_codes", "class=2;code=403;code=488;class=3")
...
</programlisting>
		</example>
	</section>
	<section id="dispatcher.p.ds_probing_mode">
		<title><varname>ds_probing_mode</varname> (int)</title>
		<para>
		Controls what gateways are tested to see if they are reachable.
		</para>

		<itemizedlist>
		<listitem>
			<para>Value 0: If set to 0, only the gateways with state PROBING are tested.
			After a gateway is probed, the PROBING state is cleared in this mode.
			This means that no probing will be executed at all only if flag in config file is set to 8/PROBING
			(please check destination list file syntaxis for more details), it will probe only one time at startup or 
			after dispatcher reload.</para>
		</listitem>
		<listitem>
			<para>Value 1: If set to 1, all gateways are tested.  If set to 1 and
			there is a failure of keepalive to an active gateway, then it is
			set to TRYING state. This means that probing will be executed all the time,
			but you can skip some servers with flag 4 in destination list file, for example.</para>
		</listitem>
		<listitem>
			<para>Value 2: if set to 2, only gateways in INACTIVE state with
			PROBING mode set are tested.</para>
		</listitem>
		<listitem>
			<para>Value 3: If set to 3, any gateway with state PROBING is continually probed
				without modifying/removing the PROBING state.  This allows selected gateways
				to be probed continually, regardless of state changes.</para>
		</listitem>
		</itemizedlist>

		<para>
		<emphasis>
			Default value is <quote>0</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set the <quote>ds_probing_mode</quote> parameter</title>
<programlisting format="linespecific">
...
modparam("dispatcher", "ds_probing_mode", 1)
...
</programlisting>
		</example>
	</section>

	<section id="dispatcher.p.ds_ping_latency_stats">
		<title><varname>ds_ping_latency_stats</varname> (int)</title>
		<para>
		Enable latency measurement when pinging nodes
		The estimator can be initialized at startup and reload using the attribute latency.
		</para>

		<itemizedlist>
		<listitem>
			<para>If set to 0, disable latency measurement.</para>
		</listitem>
		<listitem>
			<para>If set to 1, enable latency measurement.
			</para>
		</listitem>
		</itemizedlist>
		<para>
		<emphasis>
			Default value is <quote>0</quote>.
		</emphasis>
		</para>
		<example>
		<title>accessing the metrics</title>
<programlisting format="linespecific">
# using the command :
kamcmd dispatcher.list
...
DEST: {
	URI: sip:1.2.3.4
	FLAGS: AX
	PRIORITY: 9
	ATTRS: {
		BODY: latency=24
	}
	LATENCY: {
		AVG: 24.250000 # weighted moving average for the last few weeks
		STD: 1.035000  # standard deviation of AVG
		EST: 25.000000 # short term estimate, see parameter: ds_latency_estimator_alpha
		MAX: 26        # maximum value seen
		TIMEOUT: 0     # count of ping timeouts
	}
}
...
</programlisting>
		</example>
		<example>
		<title>Set the <quote>ds_ping_latency_stats</quote> parameter</title>
<programlisting format="linespecific">
...
modparam("dispatcher", "ds_ping_latency_stats", 1)
...
</programlisting>
		</example>
	</section>
	<section id="dispatcher.p.ds_latency_estimator_alpha">
		<title><varname>ds_latency_estimator_alpha</varname> (int)</title>
		<para>
		The value to be used to control the memory of the estimator EWMA "exponential weighted moving average" or
		"the speed at which the older samples are dampened"
		a good explanation can be found here : http://www.itl.nist.gov/div898/handbook/pmc/section3/pmc324.htm
		Because Kamailio doesn't support float parameter types, the value in the parameter is divided by 1000 and stored as float.
		For example, if you want to set the alpha to be 0.75, use value 750 here.
		</para>
		<para>
		<emphasis>
			Default value is <quote>900 => 0.9</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set the <quote>ds_hash_size</quote> parameter</title>
<programlisting format="linespecific">
...
modparam("dispatcher", "ds_latency_estimator_alpha", 900)
...
</programlisting>
		</example>
	</section>
	<section id="dispatcher.p.ds_hash_size">
		<title><varname>ds_hash_size</varname> (int)</title>
		<para>
		The value to be used as power of two to set the number of slots
		to hash table storing data for call load dispatching (e.g., value
		8 will create a hash table with 256 slots).
		It must be greater than 0 to enable call load dispatching feature
		(alg 10).
		</para>
		<para>
		<emphasis>
			Default value is <quote>0</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set the <quote>ds_hash_size</quote> parameter</title>
<programlisting format="linespecific">
...
modparam("dispatcher", "ds_hash_size", 9)
...
</programlisting>
		</example>
	</section>
	<section id="dispatcher.p.ds_hash_expire">
		<title><varname>ds_hash_expire</varname> (int)</title>
		<para>
		Expiration time in seconds to remove the load on a destination if no
		BYE was received meanwhile.
		</para>
		<para>
		<emphasis>
			Default value is <quote>7200</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set the <quote>ds_hash_expire</quote> parameter</title>
<programlisting format="linespecific">
...
modparam("dispatcher", "ds_hash_expire", 3600)
...
</programlisting>
		</example>
	</section>
	<section id="dispatcher.p.ds_hash_initexpires">
		<title><varname>ds_hash_initexpire</varname> (int)</title>
		<para>
		Expiration time in seconds to remove the load on a destination if no
		200 for INVITE was received meanwhile and state updated with
		ds_load_update().
		</para>
		<para>
		<emphasis>
			Default value is <quote>7200</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set the <quote>ds_hash_initexpire</quote> parameter</title>
<programlisting format="linespecific">
...
modparam("dispatcher", "ds_hash_initexpire", 60)
...
</programlisting>
		</example>
	</section>
	<section id="dispatcher.p.ds_hash_check_interval">
		<title><varname>ds_hash_check_interval</varname> (int)</title>
		<para>
		Time interval in seconds to scan internal hash table with call load
		dispatching data for expired items.
		</para>
		<para>
		<emphasis>
			Default value is <quote>30</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set the <quote>ds_hash_check_interval</quote> parameter</title>
<programlisting format="linespecific">
...
modparam("dispatcher", "ds_hash_check_interval", 60)
...
</programlisting>
		</example>
	</section>
	<section id="dispatcher.p.outbound_proxy">
		<title><varname>outbound_proxy</varname> (str)</title>
		<para>
		SIP URI of outbound proxy to be used when sending pings.
		</para>
		<para>
		<emphasis>
			By default no outbound proxy is defined.
		</emphasis>
		</para>
		<example>
		<title>Set the <quote>outbound_proxy</quote> parameter</title>
<programlisting format="linespecific">
...
modparam("dispatcher", "outbound_proxy", "sip:outbound.example.com")
...
</programlisting>
		</example>
	</section>

	<section id="dispatcher.p.ds_default_socket">
		<title><varname>ds_default_socket</varname> (str)</title>
		<para>
			Default socket to be used for sending pings and dispatching requests
			when a gateway has no send socket configured.
		</para>
		<para>
		<emphasis>
			By default no default socket is defined, the first configuration
			script <emphasis>listen</emphasis> directive is used.
		</emphasis>
		</para>
		<para>If parameter "ds_default_sockname" is set, then this parameter
		is ignored.</para>
		<example>
		<title>Set the <quote>ds_default_socket</quote> parameter</title>
<programlisting format="linespecific">
...
modparam("dispatcher", "ds_default_socket", "udp:192.168.0.125:5060")
...
</programlisting>
		</example>
	</section>

	<section id="dispatcher.p.ds_default_sockname">
		<title><varname>ds_default_sockname</varname> (str)</title>
		<para>
			Default socket name to be used for sending pings and dispatching requests
			when a gateway has no send socket configured.
		</para>
		<para>
		<emphasis>
			By default no default socket is defined, the first configuration
			script <emphasis>listen</emphasis> directive is used.
		</emphasis>
		</para>
		<para>This parameter is used even if "ds_default_socket" parameter is set
		(this parameter has higher priority).</para>
		<example>
		<title>Set the <quote>ds_default_sockname</quote> parameter</title>
<programlisting format="linespecific">
...
 listen=udp:1.2.3.4:5060 name "sock1"
...
modparam("dispatcher", "ds_default_sockname", "sock1")
...
</programlisting>
		</example>
	</section>

	<section id="dispatcher.p.ds_timer_mode">
		<title><varname>ds_timer_mode</varname> (int)</title>
		<para>
			Specify the timer process to be used by the module for
			keepalives and active dialogs tracking.
		</para>
		<para>
			It can be set to:
		</para>
		<itemizedlist>
		<listitem>
			<para>0 - use main timer process.</para>
		</listitem>
		<listitem>
			<para>1 - use secondary timer process.</para>
		</listitem>
		</itemizedlist>

		<para>
			On a server with a lot of traffic, using secondary
			timer can help with performances, because the main timer
			can be overloaded by taking care of transactions retransmissions
			and expirations of items in memory.
		</para>
		<para>
		<emphasis>
			Default value is <quote>0</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set the <quote>ds_timer_mode</quote> parameter</title>
<programlisting format="linespecific">
...
modparam("dispatcher", "ds_timer_mode", 1)
...
</programlisting>
		</example>
	</section>
	<section id="dispatcher.p.event_callback">
		<title><varname>event_callback</varname> (str)</title>
		<para>
			The name of the function in the kemi configuration file (embedded
			scripting language such as Lua, Python, ...) to be executed instead
			of event_route[...] blocks.
		</para>
		<para>
			The function receives a string parameter with the name of the event,
			the values are: 'dispatcher:dst-down', 'dispatcher:dst-up'.
		</para>
		<para>
		<emphasis>
			Default value is 'empty' (no function is executed for events).
		</emphasis>
		</para>
		<example>
		<title>Set <varname>event_callback</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("dispatcher", "event_callback", "ksr_dispatcher_event")
...
-- event callback function implemented in Lua
function ksr_dispatcher_event(evname)
	KSR.info("===== dispatcher module triggered event: " .. evname .. "\n");
	return 1;
end
...
</programlisting>
		</example>
	</section>

	<section id="dispatcher.p.ds_attrs_none">
		<title><varname>ds_attrs_none</varname> (int)</title>
		<para>
		If set to 1, "none=yes" is set in the attrs for those records that
		have no attrs value, to ensure that corresponding XAVP fields for
		records do not get mixed up.
		</para>
		<para>
		<emphasis>
			Default value is <quote>0</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set the <quote>ds_attrs_none</quote> parameter</title>
<programlisting format="linespecific">
...
modparam("dispatcher", "ds_attrs_none", 1)
...
</programlisting>
		</example>
	</section>

	<section id="dispatcher.p.ds_db_extra_attrs">
		<title><varname>ds_db_extra_attrs</varname> (str)</title>
		<para>
		Set a list of column names to be loaded from database dispatcher table
		and be concatenated to 'attrs' field. The format is:
		'aname1=cname1;aname2=cname2;...;anameN=cnameN'.
		</para>
		<para>
		The 'anameX' is the attribute name and 'cnameX' is column name. The
		additional columns must be added to database dispatcher table and their
		type must be VARCHAR (string).
		</para>
		<para>
		<emphasis>
			Default value is <quote>empty</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set the <quote>ds_db_extra_attrs</quote> parameter</title>
<programlisting format="linespecific">
...
modparam("dispatcher", "ds_db_extra_attrs", "socket=socket;pref=prefix")
...
</programlisting>
		</example>
	</section>

	<section id="dispatcher.p.ds_load_mode">
		<title><varname>ds_load_mode</varname> (int)</title>
		<para>
		If set to 1, the module throws error when failing to add a destination
		address (e.g., invalid URI). If set to 0, it skips the failing address
		and continues with the next ones.
		</para>
		<para>
		<emphasis>
			Default value is <quote>0</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set the <quote>ds_load_mode</quote> parameter</title>
<programlisting format="linespecific">
...
modparam("dispatcher", "ds_load_mode", 1)
...
</programlisting>
		</example>
	</section>

	<section id="dispatcher.p.reload_delta">
		<title><varname>reload_delta</varname> (int)</title>
		<para>
		The number of seconds that have to be waited before executing a new reload
		of dispatcher records. By default there is a rate limiting of maximum
		one reload in five seconds.
		</para>
		<para>
		If set to 0, no rate limit is configured. Note carefully: use this
		configuration only in tests environments because executing many RPC
		reload commands at the same time can cause unexpected behavior.
		</para>
		<para>
		<emphasis>
			Default value is <quote>5</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>reload_delta</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("dispatcher", "reload_delta", 1)
...
		</programlisting>
		</example>
	</section>
	</section>

	<section>
	<title>Functions</title>
	<section id="dispatcher.f.ds_select_dst">
		<title>
		<function moreinfo="none">ds_select_dst(set, alg[, limit])</function>
		</title>
		<para>
		The method selects a destination from addresses set. It returns true if
		a new destination is set. The selected address is set to dst_uri field
		(aka the outbound proxy address or the $du variable), not being visible
		in the SIP request.
		</para>
		<para>
		If the bit 2 in 'flags' parameter is set, the rest of the addresses from
		the destination set are stored in XAVP list (limited with an optional 'limit'
		parameter). You can use 'ds_next_dst()' to use next address in order to
		achieve serial forking to all possible destinations.
		</para>
		<para>Meaning of the parameters is as follows:</para>
		<itemizedlist>
		<listitem>
			<para>
			<emphasis>set</emphasis> - the id of the set from where to pick
			up destination address. It is the first column in destination
			list file. The parameter can be an integer or a variable holding
			an integer.
			</para>
		</listitem>
		<listitem>
			<para>
			<emphasis>alg</emphasis> - the algorithm used to select the
			destination address. The parameter can be an integer or a
			variable holding an integer.
			</para>
			<itemizedlist>
			<listitem>
				<para>
				<quote>0</quote> - hash over callid
				</para>
			</listitem>
			<listitem>
				<para>
				<quote>1</quote> - hash over from URI.
				</para>
			</listitem>
			<listitem>
				<para>
				<quote>2</quote> - hash over to URI.
				</para>
			</listitem>
			<listitem>
				<para>
				<quote>3</quote> - hash over request-URI.
				</para>
			</listitem>
			<listitem>
				<para>
				<quote>4</quote> - round-robin (next destination).
				</para>
			</listitem>
			<listitem>
				<para>
				<quote>5</quote> - hash over authorization-username
				(Proxy-Authorization or "normal" authorization). If no
				username is found, round robin is used.
				</para>
			</listitem>
			<listitem>
				<para>
				<quote>6</quote> - random destination (using rand()).
				</para>
			</listitem>
			<listitem>
				<para>
				<quote>7</quote> - hash over the content of PVs string.
				Note: This works only when the parameter hash_pvar is set.
				</para>
			</listitem>
			<listitem>
				<para>
				<quote>8</quote> - select destination sorted by priority
				attribute value (serial forking ordered by priority).
				</para>
			</listitem>
			<listitem>
				<para>
				<quote>9</quote> - use weight based load distribution. You
				have to set the attribute 'weight' for each address (gateway) in
				destination set. See also the description of the 'weight'
				attribute in the 'Special Attributes' section.
				</para>
			</listitem>
			<listitem>
				<para>
				<quote>10</quote> - use call load distribution. You have
				to set the attribute 'duid' (as an unique string id)
				per each address in destination set. Also, you must set
				the parameter 'ds_hash_size'.
				</para>
				<para>
				The algorithm can be used even with stateless proxy mode,
				there is no SIP dialog tracking depending on other modules,
				just an internal lightweight call tracking by Call-Id, thus
				is fast and suitable even for embedded systems.
				</para>
				<para>
				The first destination selected by this algorithm is the one
				that has the least number of calls associated. The rest of
				the destination list is taken in order of the entries in set
				- anyhow, until a re-route to next destination happens, the
				load on each address can change.
				</para>
				<para>
				This algorithm can be used only for dispatching INVITE
				requests as it is the only SIP method creating a SIP call.
				</para>
			</listitem>
			<listitem>
				<para>
				<quote>11</quote> - use relative weight based load distribution.
				You have to set the attribute 'rweight' per each address in
				destination set. Active host usage probability is
				rweight/(SUM of all active host rweights in destination group).
				</para>
				<para>
				The major difference from the weight distribution is the
				probability recalculation according to rweight value in case of
				destinations being active or inactive.
				</para>
				<para>
				For example, 100 calls in 3-destinations group with rweight params 1/2/1
				will be distributed as 25/50/25. If the third destination becomes
				inactive, the distribution is changed to 33/67/0. If the computation
				of percentage per destination is not an exact integer number, the value
				is trucated and the last destination is used to fill the remaining
				percentage till 100.
				</para>
				<para>
				Using this algorithm, you can also enable congestion control by setting the
				attribute 'cc=1', when 'cc' is enabled the 'weight' attribute will also be
				used to control congestion tolerance. When facing congestion the weight of
				a gateway is lowered by 1 for every ms of estimated congestion, a 'rweight'
				value of 50 is recommended. See the example "configuring load balancing with
				congestion detection" below.
				</para>
				<para>
				The congestion estimation is done using an EWMA (see ds_latency_estimator_alpha).
				If all the gateways in a set are above their congestion threshold(weight), the
				load distribution is instead done using the ratio of estimated congestion ms.
				</para>
				<para>
				See also the description of the 'rweight' attribute in the
				'Special Attributes' section.
				</para>
			</listitem>
			<listitem>
				<para>
				<quote>12</quote> - dispatch to all destination in setid at
				once (parallel forking). Note that the XAVPs are no longer set
				with the values of the destination records, no re-routing
				making sense in this case.
				</para>
			</listitem>
			<listitem>
				<para>
				<quote>13</quote> - latency optimized dispatching
				</para>
				<para>
				- The algorithm will load balance using round-robin prioritizing the gateways with the highest priority.
				</para>
				<para>
				- If ds_ping_latency_stats is active the algorithm will adjust the priority of the gateway automatically,
				the priority will be lowered by 1 point every time the latency ms is as high as the priority.
				</para>
				<para>
				- If the attribute 'cc=1' is set, the latency used is congestion ms : estimate (current latency ms) - average (normal condition latency ms).
				</para>
				<example>
				<title><function>latency_optimized_dispatching</function> usage</title>
				<programlisting format="linespecific">
Using this simple formula :
    ADJUSTED_PRIORITY = PRIORITY - (ESTIMATED_LATENCY_MS/PRIORITY)

GATEWAY | PRIORITY | ESTIMATED | ADJUSTED | LOAD
   #    |          |  LATENCY  | PRIORITY | DISTRIBUTION
   1    |    30    |    21     |    30    | 33%
   2    |    30    |    91     |    27    | 0%
   3    |    30    |    61     |    28    | 0%
   4    |    30    |    19     |    30    | 33%
   5    |    30    |    32     |    29    | 0%
   6    |    30    |    0      |    30    | 33%
   7    |    30    |    201    |    24    | 0%


With congestion control the formula becomes :
    CONGESTION_MS = CURRENT_LATENCY_MS - NORMAL_CONDITION_LATENCY_MS
    ADJUSTED_PRIORITY = PRIORITY - (CONGESTION_MS/PRIORITY)
				</programlisting>
				</example>
			</listitem>
			<listitem>
				<para>
				<quote>X</quote> - if the algorithm is not implemented, the
				first entry in set is chosen.
				</para>
			</listitem>
			</itemizedlist>
		</listitem>
		<listitem>
			<para>
			<emphasis>limit</emphasis> - the maximum number of items to be
			stored in XAVP list for further fail-overs (the first selected
			destination and default destination are the first to be put in
			the list)
			</para>
		</listitem>
		</itemizedlist>
		<para>
		This function can be used from REQUEST_ROUTE, FAILURE_ROUTE.
		</para>
		<example>
		<title><function>ds_select_dst</function> usage</title>
		<programlisting format="linespecific">
...
ds_select_dst("1", "0");
...
$var(a) = 4;
ds_select_dst("1", "$var(a)");
...
ds_select_dst("1", "4", "3");
...
</programlisting>
		</example>
		<example>
		<title>configuring load balancing with congestion detection</title>
		<programlisting format="linespecific">
...
# sample of SQL provisionning statements
INSERT INTO "dispatcher" 
VALUES(1,1,'sip:192.168.0.1:5060',0,12,'rweight=50;weight=50;cc=1;','');
INSERT INTO "dispatcher" 
VALUES(2,1,'sip:192.168.0.2:5060',0,12,'rweight=50;weight=50;cc=1;','');
...
modparam("dispatcher", "ds_ping_interval", 1) # ping gateways once/second
modparam("dispatcher", "ds_ping_latency_stats", 1) # update congestion metrics
# configure the latency estimator
modparam("dispatcher", "ds_latency_estimator_alpha", 900)
...
if (!ds_select_dst("1", "11")) { # use relative weight based load distribution
...
# sample of output from 'kamcmd dispatcher.list'
DEST: {
	URI: sip:192.168.0.1:5060
	FLAGS: AP
	PRIORITY: 12
	ATTRS: {
		BODY: rweight=50;weight=50;cc=1 # configuration values
		DUID: 
		MAXLOAD: 0
		WEIGHT: 50
		RWEIGHT: 50
		SOCKET: 
		SOCKNAME: 
		OBPROXY: 
	}
	LATENCY: {
		AVG: 20.104000
		STD: 1.273000
		# estimated congestion is currently 25ms = 45ms(EST) -20ms(AVG)
		EST: 45.005000
		MAX: 132
		TIMEOUT: 3
	}
}
...
</programlisting>
		</example>
	</section>
	<section id="dispatcher.f.ds_select_domain">
		<title>
		<function moreinfo="none">ds_select_domain(set, alg[, limit])</function>
		</title>
		<para>
		The method selects a destination from addresses set and rewrites the
		host and port from R-URI. The parameters have same meaning as for
		ds_select_dst().
		</para>
		<para>
		If the bit 2 in 'flags' is set, the rest of the addresses from the
		destination set are stored in XAVP list (limited with an optional 'limit'
		parameter). You can use 'ds_next_domain()' to use next address to
		achieve serial forking to all possible destinations.
		</para>
		<para>
		This function can be used from REQUEST_ROUTE, FAILURE_ROUTE.
		</para>
		<example>
		<title><function>ds_select_domain</function> usage</title>
		<programlisting format="linespecific">
...
$var(a) = 4;
if(ds_select_domain("1", "$var(a)")) {
    t_relay();
    exit;
}
...
</programlisting>
		</example>
	</section>
	<section id="dispatcher.f.ds_select">
		<title>
		<function moreinfo="none">ds_select(set, alg [, limit])</function>
		</title>
		<para>
		The method selects a destination from addresses set and adds it
		in the XAVP specified for this module. It is not updating R-URI
		nor the destination URI. The parameters have same
		meaning as for ds_select_dst().
		</para>
		<para>
		If the bit 2 in 'flags' is set, the rest of the addresses from the
		destination set are stored in XAVP list (limited with an optional 'limit'
		parameter). You can execute 'ds_next_domain()' or 'ds_next_dst()' to use
		next address to achieve serial forking to all possible destinations.
		</para>
		<para>
		This function can be used from ANY_ROUTE.
		</para>
		<example>
		<title><function>ds_select</function> usage</title>
		<programlisting format="linespecific">
...
$var(a) = 4;
if(ds_select("1", "$var(a)")) {
    ds_next_domain();
    t_relay();
    exit;
}
...
</programlisting>
		</example>
	</section>
	<section id="dispatcher.f.ds_select_routes">
		<title>
		<function moreinfo="none">ds_select_routes(rules, mode [, limit])</function>
		</title>
		<para>
		The method selects destinations following the rules combining groups add
		algorithms, controlling where the first destination address is pushed,
		and optionally setting a limit of selected addresses.
		</para>
		<para>Parameters:</para>
		<itemizedlist>
		<listitem>
			<para><emphasis>rules</emphasis> - a string in the format
			"grp1=alg1;grp2=alg2;...grpN=algN", where grpX is an integer number
			identifying a dispatcher set id and algN is a dispatcher algorithm
			identifier. No white spaces should be given in the parameter value.
			The parameter can contain pseudo-variables.
			</para>
		</listitem>
		<listitem>
			<para><emphasis>mode</emphasis> - control where to push the first
			selected target address. Valid values are: '0', 'd' or 'D' to push
			the address in destination URI; '1', 'r' or 'R' to push the address
			in R-URI; '2', 'x' or 'X' to push the address only in the XAVP when
			failure rerouting is enabled. Note that only first character of the
			parameter matters, therefore one can use a more meaningful value
			such as 'ruri' instead of 'r'. The parameter can contain pseudo
			variables.
			</para>
		</listitem>
		<listitem>
			<para><emphasis>limit</emphasis> - a positive integer value to
			restrict the number of selected target addresses. If it is 0, then
			no limit is considered. The parameter can be a static integer or
			a variable holding an integer value.
			</para>
		</listitem>
		</itemizedlist>
		<para>
		If the bit 2 in 'flags' is set, the rest of the addresses from the
		destination groups are stored in XAVP list (limited with an optional 'limit'
		parameter). You can execute 'ds_next_domain()' or 'ds_next_dst()' to use
		next address to achieve serial forking to all possible destinations.
		</para>
		<para>
		This function can be used from ANY_ROUTE.
		</para>
		<example>
		<title><function>ds_select_routes</function> usage</title>
		<programlisting format="linespecific">
...
$var(alg) = 4;
$var(limit) = 8;
if(ds_select_routes("1=4;2=$var(alg)", "ruri", "$var(limit)")) {
    t_on_failure("REROUTE");
    t_relay();
    exit;
}
failure_route[REROUTE] {
    if(t_check_status("408|5[0-9][0-9]")) {
        if(ds_next_domain()) {
            t_on_failure("REROUTE");
            t_relay();
            exit;
        }
    }
}
...
</programlisting>
		</example>
	</section>
	<section>
		<title>
		<function moreinfo="none">ds_next_dst()</function>
		</title>
		<para>
		Takes the next destination address from the corresponding XAVPs
		and sets the dst_uri (outbound proxy address).
		</para>
		<para>
		This function can be used from REQUEST_ROUTE, FAILURE_ROUTE.
		</para>
	</section>
	<section>
		<title>
		<function moreinfo="none">ds_next_domain()</function>
		</title>
		<para>
		Takes the next destination address from the corresponding XAVPs
		and sets the domain part of the request URI.
		</para>
		<para>
		This function can be used from REQUEST_ROUTE, FAILURE_ROUTE.
		</para>
	</section>
	<section id="dispatcher.f.ds_set_dst">
		<title>
		<function moreinfo="none">ds_set_dst()</function>
		</title>
		<para>
		Takes the current destination address from the corresponding XAVPs
		and sets the dst_uri (outbound proxy address).
		</para>
		<para>
		This function can be used from REQUEST_ROUTE, FAILURE_ROUTE.
		</para>
	</section>
	<section id="dispatcher.f.ds_set_domain">
		<title>
		<function moreinfo="none">ds_set_domain()</function>
		</title>
		<para>
		Takes the current destination address from the corresponding XAVPs
		and sets the domain part of the request URI.
		</para>
		<para>
		This function can be used from REQUEST_ROUTE, FAILURE_ROUTE.
		</para>
	</section>
	<section id="dispatcher.f.ds_mark_dst">
		<title>
		<function moreinfo="none">ds_mark_dst([state])</function>
		</title>
		<para>
		Mark the last used address from destination set as inactive
		("i"/"I"), active ("a"/"A"), disabled ("d"/"D") or trying ("t"/"T").
		Apart of disabled state, a destination can be set in probing mode by
		adding ("p"/"P") flag. With this function, an automatic detection
		of failed gateways can be implemented. When an address is marked as
		inactive or disabled, it will be ignored by 'ds_select_dst' and
		'ds_select_domain'.
		</para>
		<para>
		The parameter state is optional, when it is missing, then
		the destination will be marked inactive (i.e., same as 'i').
		</para>
		<para>Possible values for state parameter:</para>
		<itemizedlist>
		<listitem>
			<para><emphasis>"a" or "A"</emphasis> - the last destination
				should be set to active and the error-counter should set to "0".
			</para>
		</listitem>
		<listitem>
			<para><emphasis>"i" or "I"</emphasis> - the last destination
				should be set to inactive and will be ignored in future
				requests.</para>
		</listitem>
		<listitem>
			<para><emphasis>"t" or "T"</emphasis> - the last destination
				should be set to temporary trying state and failure counter
				is incremented. When the failure counter reaches the threshold,
				the destination will be set inactive.
			</para>
		</listitem>
		<listitem>
			<para><emphasis>"p" and "P"</emphasis> - this has to be used in
				addition to one of the previous flags - the last destination
				will be set to probing. This mean the destination will be pinged
				with SIP OPTIONS requests from time to time to detect if it is
				up or down.</para>
		</listitem>
		</itemizedlist>
		<para>
		This function can be used from REQUEST_ROUTE, FAILURE_ROUTE.
		</para>
		<example>
		<title><function>ds_mark_dst</function> usage</title>
		<programlisting format="linespecific">
...
failure_route[tryagain] {
...
   if(t_check_status("500"))
      ds_mark_dst("ip"); # set to inactive and probing
...
}
...
</programlisting>
		</example>
	</section>
	<section  id="dispatcher.f.ds_list_exists">
		<title>
		<function moreinfo="none">ds_list_exists(groupid)</function>
		</title>
		<para>
		Function alias: ds_list_exist(groupid)
		</para>
		<para>
		Check if a specific group is defined in dispatcher list
		or database.
		</para>
		<itemizedlist>
		<listitem>
			<para><emphasis>groupid</emphasis> - A group ID to check.
			</para>
		</listitem>
		</itemizedlist>
		<para>
			It returns true (value 1) if the group exists, or otherwise false
			(-1 when the group is not found; -2 when evaluating the parameter
			fails).
		</para>
		<para>
			This function can be used from ANY_ROUTE.
		</para>
		<example>
		<title><function>ds_list_exists</function> usage</title>
		<programlisting format="linespecific">
...
if(ds_list_exists("10")) {
    ...
}
...
</programlisting>
	</example>
	</section>
	<section  id="dispatcher.f.ds_is_from_list">
		<title>
		<function moreinfo="none">ds_is_from_list([groupid [, mode [, uri] ] ])</function>
		</title>
		<para>
		This function returns true, if there is a match of source address or uri
		with an address in the given group of the dispatcher-list; otherwise false.
		</para>
		<para>Description of parameters:</para>
		<itemizedlist>
		<listitem>
			<para><emphasis>groupid</emphasis> (optional) - if not given or its
				value is -1, the matching will be done over all addresses in
				all dispatcher groups. Otherwise the matching will be done only
				against the addresses in the specific group id. The parameter
				can be an integer or a variable holding an integer value.
			</para>
		</listitem>
		<listitem>
			<para><emphasis>mode</emphasis> - (optional) - a bitmask to specify
				how the matching should be done. If parameter is 0, all ip, port and
				proto are matched and active status is ignored.
				If bit one is set, then port is ignored.
				If bit two is set, then protocol is ignored.
				If bit three is set, then state must be active.	The parameter
				can be an integer or a variable holding an integer value.
				It must be provided if the uri parameter is provided.
			</para>
		</listitem>
        <listitem>
            <para><emphasis>uri</emphasis> (optional) - if parameter is empty or missing,
                the matching is done against source IP, port and protocol.
                Otherwise the value has to be a valid SIP URI, used to match
                against addresses in the dispatcher list. Only IP, port and
                protocol are matches, any additional parameters are ignored.
                The parameter can be a static or dynamic (with variables)
                string. The domain part of the URI can be an IP address or
                a hostname.
            </para>
        </listitem>
		</itemizedlist>

		<para>
		Upon a match, the variable specified by 'setid_pvname' parameter will
		be set to groupid of matching address and the attributes will be set in
		variable specified by 'attrs_pvname'.
		</para>
		<para>
		Note that for backward compatibility mode, when no parameter is given
		or only groupid is given, the matching is done only for IP address
		and port (protocol is ignored).
		</para>
		<para>
			This function can be used from ANY_ROUTE.
		</para>
		<example>
		<title><function>ds_is_from_list</function> usage</title>
		<programlisting format="linespecific">
...
if(ds_is_from_list()) {
    ...
}
if(ds_is_from_list("10")) {
    ...
}
if(ds_is_from_list("10", "3")) {
    ...
}
if(ds_is_from_list("10", "3", "sip:127.0.0.1:5080")) {
    ...
}
...
</programlisting>
		</example>
	</section>
	<section id="dispatcher.f.ds_load_update">
		<title>
		<function moreinfo="none">ds_load_update()</function>
		</title>
		<para>
		Updates the load state:
		</para>
		<itemizedlist>
		<listitem>
			<para>if it is a BYE or CANCEL - remove the load from
			destination address used to forward the INVITE</para>
		</listitem>
		<listitem>
			<para>if it is a reply to INVITE - set internal state
				to confirmed for call load structure when reply code is
				2xx.</para>
		</listitem>
		</itemizedlist>
		<para>
			This function can be used from REQUEST_ROUTE, FAILURE_ROUTE,
			BRANCH_ROUTE and ONREPLY_ROUTE.
		</para>
	</section>
	<section>
		<title>
		<function moreinfo="none">ds_load_unset()</function>
		</title>
		<para>
		Remove the call load for the destination that routed the call.
		</para>
		<para>
			This function can be used from REQUEST_ROUTE, FAILURE_ROUTE,
			BRANCH_ROUTE and ONREPLY_ROUTE.
		</para>
		<example>
		<title><function>ds_load_unset</function> usage</title>
		<programlisting format="linespecific">
...
route {
    ...
	if(is_method("BYE|CANCEL"))
        ds_load_update();
    ...
	ds_select_dst("1", "10");
    ...
}

onreply_route {
    ...
    if(is_method("INVITE")
	{
        if(status=~"2[0-9][0-9]")
            ds_load_update();
        else if(status=~"[3-7][0-9][0-9]")
            ds_load_unset();
    }
    ...
}
...
</programlisting>
		</example>
	</section>
	<section id="dispatcher.f.ds_reload">
		<title>
		<function moreinfo="none">ds_reload()</function>
		</title>
		<para>
		Reloads the groups and included destinations.
		</para>
		<para>
		Name: <emphasis>ds_reload</emphasis>
		</para>
		<para>Parameters: <emphasis>none</emphasis></para>
		<para>
		This function can be used from ANY_ROUTE.
		</para>
	</section>
	</section>

	<section>
	<title>RPC Commands</title>
	<section id="dispatcher.r.set_state">
		<title>
		<function moreinfo="none">dispatcher.set_state</function>
		</title>
		<para>
		Sets the state for a destination address (can be use to mark the destination
		as active or inactive).
		</para>
		<para>
		Name: <emphasis>dispatcher.set_state</emphasis>
		</para>
		<para>Parameters:</para>
		<itemizedlist>
			<listitem><para>_state_ : state of the destination address</para>
			      <itemizedlist>
	                 <listitem><para> <quote>a</quote>: active</para></listitem>
			         <listitem><para> <quote>i</quote>: inactive</para></listitem>
			         <listitem><para> <quote>t</quote>: trying</para></listitem>
			         <listitem><para> <quote>d</quote>: disabled</para></listitem>
				  </itemizedlist>
				  <para>The states <quote>a</quote>, <quote>i</quote> or
					  <quote>t</quote> can be followed by <quote>p</quote>
					  to set probing mode (e.g. 'ap', 'ip' or 'tp').</para>
			</listitem>

			<listitem><para>_group_: destination group id</para></listitem>

			<listitem><para>_address_: address of the destination in the _group_
					or 'all' to update all destinations in the group</para></listitem>
		</itemizedlist>
		<para>
		Example:
		</para>
<programlisting  format="linespecific">
...
# prototype: &sercmd; dispatcher.set_state _state_ _group_ _address_
&sercmd; dispatcher.set_state ip 2 sip:127.0.0.1:5080
&sercmd; dispatcher.set_state ip 3 all
...
</programlisting>
    </section>
	<section id="dispatcher.r.set_duid_state">
		<title>
		<function moreinfo="none">dispatcher.set_duid_state</function>
		</title>
		<para>
		Sets the state for a destination by matching on 'duid' attribute. The
		parameters first two parameter 'state' and 'group' are the same like
		for RPC command 'dispatcher.set_state'. The third parameter 'duid' is
		the value to be matched against the 'duid' attribute of dispatcher
		destinations.
		</para>
		<para>
		Example:
		</para>
<programlisting  format="linespecific">
...
# prototype: &sercmd; dispatcher.set_duid_state _state_ _group_ _duid_
&sercmd; dispatcher.set_duid_state ip 2 xyz
...
</programlisting>
    </section>
	<section id="dispatcher.r.list">
		<title>
		<function moreinfo="none">dispatcher.list</function>
		</title>
		<para>
		Lists the groups and included destinations.
		</para>
		<para>
		Name: <emphasis>dispatcher.list</emphasis>
		</para>
		<para>Parameters: <emphasis>none</emphasis></para>
		<para>
		Example:
		</para>
<programlisting  format="linespecific">
		&sercmd; dispatcher.list
...
DEST: {
        URI: sip:192.168.0.1:5060
        FLAGS: AP
        PRIORITY: 12
}
...
</programlisting>
		<para>FLAGS consist out of 2 letters. First letter describe status of
		destination: A-active, I – inactive, T – trying, D – disabled. Second
		letter might be P or X. P is for probing, so AP means destination
		is active and it is tested by SIP options continuously. X means that
		there are no probing or sip pinging. So AX means that destination is
		assumed as active and it is not tested by SIP options. DX
		respectively is disabled destination that is not tested, etc.
		</para>
	</section>
	<section id="dispatcher.r.reload">
		<title>
		<function moreinfo="none">dispatcher.reload</function>
		</title>
		<para>
		Reloads the groups and included destinations. The command is
		disabled for call load based dispatching (algorithm 10) since
		removal of destinations may leave the list of active
		calls with broken references.
		</para>
		<para>
		Name: <emphasis>dispatcher.reload</emphasis>
		</para>
		<para>Parameters: <emphasis>none</emphasis></para>
		<para>
		Example
		</para>
<programlisting  format="linespecific">
		&sercmd; dispatcher.reload
</programlisting>
	</section>

	<section id="dispatcher.r.ping_active">
		<title>
		<function moreinfo="none">dispatcher.ping_active</function>
		</title>
		<para>
		Sets the global state for sending keepalive requests to destinations.
		</para>
		<para>
		Name: <emphasis>dispatcher.ping_active</emphasis>
		</para>
		<para>Parameters:</para>
		<itemizedlist>
			<listitem><para>_state_ : state of sending keepalives</para>
			    <itemizedlist>
	               <listitem><para> <quote>0</quote>: inactive (don't send)</para></listitem>
			       <listitem><para> <quote>1</quote>: active (send)</para></listitem>
				</itemizedlist>
			</listitem>
		</itemizedlist>
		<para>
			If the state parameter is missing, the current state is returned.
			When state is changed, new and old values of the state are returned.
			Default value for state is 1.
		</para>
		<para>
		Example:
		</para>
<programlisting  format="linespecific">
...
# prototype: &kamcmd; dispatcher.ping_active _state_
&kamcmd; dispatcher.ping_active 0
...
</programlisting>
	</section>
		<section id="dispatcher.r.add">
		<title>
		<function moreinfo="none">dispatcher.add</function>
		</title>
		<para>
		Add a destination address to the in-memory dispatcher list. Reloading the dispatcher will remove
		any destinations that are only added to the in-memory dispatcher list.
		</para>
		<para>
		Name: <emphasis>dispatcher.add</emphasis>
		</para>
		<para>Parameters:</para>
		<itemizedlist>
			<listitem><para>_group_: destination group id</para></listitem>

			<listitem><para>_address_: address of the destination in the _group_</para></listitem>

			<listitem><para>_flags_ (optional): as described in the list file format,
			default 0</para></listitem>

			<listitem><para>_attrs_ (optional): as described in the list file format,
			default ""</para></listitem>

		</itemizedlist>
		<para>
		Example:
		</para>
<programlisting  format="linespecific">
...
# prototype: &sercmd; dispatcher.add _group_ _address_ _flags_ _attrs_
&sercmd; dispatcher.add 2 sip:127.0.0.1:5080
&sercmd; dispatcher.add 3 sip:127.0.0.1:5075 8
&sercmd; dispatcher.add 3 sip:127.0.0.1:5075 0 duid=abc;socket=udp:127.0.0.1:5060
...
</programlisting>
	</section>
		<section id="dispatcher.r.remove">
		<title>
		<function moreinfo="none">dispatcher.remove</function>
		</title>
		<para>
		Remove a destination address from the in-memory dispatcher list. Reloading
		the dispatcher from file or database will re-add destinations that are
		removed using this command.
		</para>
		<para>
		This command will remove all entries that match the group and address.
		</para>
		<para>
		Name: <emphasis>dispatcher.remove</emphasis>
		</para>
		<para>Parameters:</para>
		<itemizedlist>
			<listitem><para>_group_: destination group id</para></listitem>

			<listitem><para>_address_: address of the destination in the _group_</para></listitem>

		</itemizedlist>
		<para>
		Example:
		</para>
<programlisting  format="linespecific">
...
# prototype: &sercmd; dispatcher.remove _group_ _address_
&sercmd; dispatcher.remove 2 sip:127.0.0.1:5080
&sercmd; dispatcher.remove 3 sip:127.0.0.1:5075;transport=udp
...
</programlisting>
	</section>
		<section id="dispatcher.r.hash">
		<title>
		<function moreinfo="none">dispatcher.hash</function>
		</title>
		<para>
		Compute the hash id corresponding to the string parameter values.
		</para>
		<para>
		Return the hash id and the corresponding slot, if 'nslots' parameter
		is not 0.
		</para>
		<para>
		Name: <emphasis>dispatcher.hash</emphasis>
		</para>
		<para>Parameters:</para>
		<itemizedlist>
			<listitem><para>_nslots_: number of slots</para></listitem>
			<listitem><para>_val1_: string value</para></listitem>
			<listitem><para>_val2_: (optional) string value</para></listitem>
		</itemizedlist>
		<para>
		It can be useful to find what address in a destination group (setid) is
		going to be used when hashing a value or a URI. For a URI, the
		corresponding username and domain have to be provided as _val1_ and
		_val2_. If the URI has a port different than 5060 (or 5061 for TLS),
		then the _val2_ has to be 'domain:port'. The _nslots_ has to be the
		number of addresses in the group (setid). The returned 'slot' value
		represents the index of the address to be used for routing.
		</para>
		<para>
		Example:
		</para>
<programlisting  format="linespecific">
...
# prototype: kamctl rpc dispatcher.hash _nslots_ _val1_ [_val2_]
kamctl rpc dispatcher.hash 0 alice server.com
kamctl rpc dispatcher.hash 4 bob server.com
...
</programlisting>
    </section>

   </section>

	<section id="dispatcher.ex.install">
	<title>Installation and Running</title>
	<section>
		<title>Destination List File</title>
		<para>
		Each destination point must be on one line. First token is the set
		id (an integer value, also referenced by group id), followed by
		destination address (string value in full SIP URI format).
		</para>
		<para>
		Optionally, these fields can be followed by:
		</para>
		<itemizedlist>
			<listitem>
			<para>flags - control the mode of using the destination address and
			sending keepalives. It is a bitwise value that can be built using
			the following flags:
			<itemizedlist>
				<listitem><para>1 (bit at index 0 - 1 &lt;&lt;0) - inactive destination</para>
				</listitem>
				<listitem><para>2 (bit at index 1 - 1 &lt;&lt;1) - temporary trying
				destination (in the way to become inactive if it does not reply to
				keepalives - there is a module parameter to set the threshold of
				failures)</para>
				</listitem>
				<listitem><para>4 (bit at index 2 - 1 &lt;&lt;2) - admin disabled destination</para>
				</listitem>
				<listitem><para>8 (bit at index 3 - 1 &lt;&lt;3) - probing destination (sending keep alives);</para>
				</listitem>
				<listitem><para>16 (bit at index 4 - 1 &lt;&lt;4) - skip DNS A/AAAA resolve at startup,
				useful when the hostname of the destination address is a NAPTR or SRV record only.
				Such addresses cannot be matched anymore with ds_is_from_list(...).</para>
				</listitem>
			</itemizedlist>
			</para>
			</listitem>
			<listitem>
			<para>priority: sets the priority in destination list (based on it
			is done the initial ordering inside the set)</para>
			</listitem>
			<listitem>
			<para>attributes: extra fields in form of
				name1=value1;...;nameN=valueN.
			</para>
			</listitem>
		</itemizedlist>
		<section id="dispatcher.ex.attributes">
			<title>Special Attributes</title>
			<para>
			There are some predefined names:
			<itemizedlist>
						<listitem>
							<para>'duid' - used for call load dispatching. It must be an unique
								value to identify a destination (gateway address). Practically the
								load within the group is associated with this value.></para>
						</listitem>
						<listitem>
							<para>'maxload' - used for call load dispatching. It must be a positive
								integer, defining the upper limit of active calls per destination.
								When the limit is reached, then the gateway is no longer selected
								for new calls until an exiting call via that gateway is terminated.
								If set to 0, then no active call limit is used.></para>
						</listitem>
						<listitem>
							<para>'weight' - used for weight based load distribution. It must be set
								to a positive integer value beteen 1 and 100 (inclusive the limits),
								otherwise the destination address is ignored (its weight set to 0).
								The value represents the percent of calls to be sent to that gateways.
								The sum must not exceed 100, otherwise the destinations whose weight
								added to the sum go over 100 are ignored. If the sum is less than 100,
								then the last destination is used to fill the missing percentage. See
								also the description of the corresponding algorithm parameter for
								ds_select_dst().</para>
						</listitem>
						<listitem>
							<para>'rweight' - used for relative weight based load distribution. It
								must be set to a positive integer value between 1 and 100 (inclusive
								the limits) otherwise host will be excluded from relative weight
								distribution type - its rweight is set to 0. See also the description
								of the corresponding algorithm parameter for ds_select_dst().</para>
						</listitem>
						<listitem>
							<para>'socket' - used to set the sending socket for the gateway. It is
								used for sending the SIP traffic as well as OPTIONS
								keepalives.</para>
						</listitem>
						<listitem>
							<para>'sockname' - used to set by name the sending socket for the
								gateway. It is used for sending the SIP traffic as well as OPTIONS
								keepalives and has priority over 'socket' attribute.</para>
						</listitem>
						<listitem>
							<para>'ping_from' - used to set the From URI in OPTIONS keepalives. It
								overwrites the general ds_ping_from parameter.</para>
						</listitem>
						<listitem>
							<para>'obproxy' - SIP URI of outbound proxy to be used when sending
								pings. It overwrites the general ds_outbound_proxy parameter.</para>
						</listitem>
						<listitem>
							<para>'latency' - latency_stats initialization in ms.</para>
						</listitem>
					</itemizedlist>
		</para>
		</section>
		<section id="dispatcher.ex.fileforma">
			<title>File Format</title>
		<para>
		Line format is:
		</para>
		<programlisting format="linespecific">
...
setid(int) destination(sip uri) flags(int,opt) priority(int,opt) attrs(str,opt)
...
</programlisting>

		<para>
		Full line example:
		</para>
		<programlisting format="linespecific">
...
1 sip:127.0.0.1:5080 0 0 duid=abc;socket=udp:192.168.0.125:5060;my=xyz;ping_from=sip:myproxy.com
...
</programlisting>

		<para>
		For database, each element of a line resides in a different column.
		Next is a dispatcher.list file example:
		</para>
		<example>
		<title>dispatcher list file</title>
		<programlisting format="linespecific">
...
<xi:include href="dispatcher.list" parse="text"/>
...
</programlisting>
		</example>
		</section>
		</section>

		<section id="dispatcher.ex.config">
		<title>&kamailio; config file</title>
		<para>
		Next listing shows a sample config for using the dispatcher module.
		</para>
		<example>
		<title>&kamailio; config script - sample dispatcher usage</title>
		<programlisting format="linespecific">
...
<xi:include href="dispatcher.cfg" parse="text"/>
...
		</programlisting>
		</example>
	</section>
	</section>

        <section id="dispatcher.ex.event_routes">
        <title>Event routes</title>
        <section>
                <title>
                <function moreinfo="none">dispatcher:dst-down</function>
                </title>
                <para>
			When defined, the module calls event_route[dispatcher:ds-down]
			when a destination goes down (becomes probing). A typical use
			case is to update NMC equipment as to the status of a destination.
                </para>
        <programlisting  format="linespecific">
...
event_route[dispatcher:dst-down] {
    xlog("L_ERR", "Destination down: $rm $ru ($du)\n");
}
...
                </programlisting>
	</section>
        <section>
                <title>
                <function moreinfo="none">dispatcher:dst-up</function>
                </title>
                <para>
			When defined, the module calls event_route[dispatcher:ds-up]
			when a destination that was previously down (probing) comes up.
			A typical use case is to update NMC equipment as to the status
			of a destination.
                </para>
        <programlisting  format="linespecific">
...
event_route[dispatcher:dst-up] {
    xlog("L_ERR", "Destination up: $rm $ru\n");
}
...
                </programlisting>
    </section>
    </section>

</chapter>
