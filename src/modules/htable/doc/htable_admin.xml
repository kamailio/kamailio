<?xml version="1.0" encoding='ISO-8859-1'?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
"http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd" [

<!-- Include general documentation entities -->
<!ENTITY % docentities SYSTEM "../../../../doc/docbook/entities.xml">
%docentities;

]>
<!-- Module User's Guide -->

<chapter>

	<title>&adminguide;</title>

	<section>
	<title>Overview</title>
	<para>
		The module adds a hash table container to the configuration language. The
		hash table is stored in shared memory and the access to it can be
		done via pseudo-variables: $sht(htname=&gt;name). The module supports
		definition of many hash tables and can load values at startup from
		a database table.
	</para>
	<para>
		A typical use case for the SIP server is to implement a cache system
		in configuration file - if a value is not found in hash table, load
		it from database and store it in hash table so next time the access to
		it is very fast. In the definition of the table you can define the
		default expiration time of cached items. The expiration time can
		be adjusted per item via assignment operation at runtime.
	</para>
	<para>
		Replication between multiple servers is performed automatically (if
		enabled) via the DMQ module.
	</para>
	<para>
		You can read more about hash tables at:
		http://en.wikipedia.org/wiki/Hash_table.
	</para>
	<para>
		The <quote>name</quote> can be a static string or can include pseudo-
		variables that will be replaced at runtime.
	</para>
	<example>
		<title>Accessing $sht(htname=&gt;key)</title>
	<programlisting format="linespecific">
...
modparam("htable", "htable", "a=&gt;size=8;")
...
$sht(a=&gt;test) = 1;
$sht(a=&gt;$ci::srcip) = $si;
...
</programlisting>
	</example>
	<para>
		The next example shows a way to protect against dictionary attacks. If
		someone fails to authenticate 3 times, it is forbidden for 15 minutes.
		Authenticatiion against database is expensive as it does a select
		on the <quote>subscriber</quote> table. By disabling the DB auth for 15 minutes,
		resources on the server are saved and time to discover the password is increased
		substantially. Additional alerting can be done by writing a message
		to syslog or sending email, etc.
	</para>
	<para>
		To implement the logic, two hash table variables are used: one counting
		the failed authentications per user and one for storing the time of the
		last authentication attempt. To ensure a unique name per user, the
		hash table uses a combination of authentication username and text
		<quote>::auth_count</quote> and <quote>::last_auth</quote>.
	</para>
	<example>
	<title>Dictionary attack limitation</title>
	<programlisting format="linespecific">
...
modparam("htable", "htable", "a=&gt;size=8;")
...
if(is_present_hf("Authorization"))
{
    if($sht(a=&gt;$au::auth_count)==3)
    {
		$var(exp) = $Ts - 900;
        if($sht(a=&gt;$au::last_auth) &gt; $var(exp))
        {
            sl_send_reply("403", "Try later");
            exit;
        } else {
            $sht(a=&gt;$au::auth_count) = 0;
        }
    }
    if(!www_authenticate("$td", "subscriber"))
    {
        switch ($retcode) {
            case -1:
                sl_send_reply("403", "Forbidden");
            exit;
            case -2:
                if($sht(a=&gt;$au::auth_count) == $null)
                    $sht(a=&gt;$au::auth_count) = 0;
                $sht(a=&gt;$au::auth_count) = $sht(a=&gt;$au::auth_count) + 1;
                if($sht(a=&gt;$au::auth_count) == 3)
                    xlog("auth failed 3rd time - src ip: $si\n");
                $sht(a=&gt;$au::last_auth) = $Ts;
            break;
        }
        www_challenge("$td"/*realm*/,"0"/*qop*/);
        exit;
    }
    $sht(a=&gt;$au::auth_count) = 0;
} else {
    www_challenge("$td","0");
    exit;
}
...
</programlisting>
	</example>
	<para>
		The module also provides a way to store multiple values for a single key.
		This is emulated by storing individual keys as 'key_name[n]', where n is
		incremented for each key. The total number of keys is stored in a
		dedicated key, by default: 'key_name::size'.
	</para>
	<para>
		The array is built when the table is loaded in memory and afterwards all
		the keys are treated as individual keys.
		If a particular entry in the array is deleted, it is the administrator's
		responsibility to update the size of the array and any other elements
		(if required).
	</para>
	<example>
	<title>Storing array values</title>
	<programlisting format="linespecific">
# Example of dbtext with multiple keys
$ cat /usr/local/etc/kamailio/dbtext/htable
1:key:1:0:value3:0
2:key:1:0:value2:0
3:key:1:0:value1:0

# The array key will be loaded in memory in the following format:
$ kamcmd htable.dump htable
{
        entry: 35
        size: 1
        slot: {
                item: {
                        name: key[0]
                        value: value1
                }
        }
}
{
        entry: 50
        size: 1
        slot: {
                item: {
                        name: key::size
                        value: 3
                }
        }
}
{
        entry: 67
        size: 1
        slot: {
                item: {
                        name: key[1]
                        value: value2
                }
        }
}
{
        entry: 227
        size: 1
        slot: {
                item: {
                        name: key[2]
                        value: value3
                }
        }
}

# Now let's delete a particular entry in the array: key[0].
$ kamcmd htable.delete htable key[0]

# The array key will look like this after a key was deleted:
$ kamcmd htable.dump htable
{
        entry: 50
        size: 1
        slot: {
                item: {
                        name: key::size
                        value: 3
                }
        }
}
{
        entry: 67
        size: 1
        slot: {
                item: {
                        name: key[1]
                        value: value2
                }
        }
}
{
        entry: 227
        size: 1
        slot: {
                item: {
                        name: key[2]
                        value: value3
                }
        }
}
</programlisting>
	</example>

	</section>
	<section>
	<title>Dependencies</title>
	<section>
		<title>&kamailio; Modules</title>
		<para>
		The following modules must be loaded before this module:
			<itemizedlist>
			<listitem>
			<para>
				<emphasis>If DMQ replication is enabled, the DMQ module must be loaded first.</emphasis>.
			</para>
			</listitem>
			</itemizedlist>
		</para>
	</section>
	<section>
		<title>External Libraries or Applications</title>
		<para>
		The following libraries or applications must be installed before running
		&kamailio; with this module loaded:
			<itemizedlist>
			<listitem>
			<para>
				<emphasis>None</emphasis>.
			</para>
			</listitem>
			</itemizedlist>
		</para>
	</section>
	<section>
		<title>Loading from database</title>
		<para>
		The module is able to load values in a hash table at startup upon
		providing a DB URL and table name.
		</para>
		<para>
			The structure of the table must contain:
		</para>
			<itemizedlist>
			<listitem>
			<para>
				<emphasis>key name</emphasis> - string containing the name of
				the key.
			</para>
			</listitem>
			<listitem>
			<para>
				<emphasis>key type</emphasis> - the type of the key
			</para>
			<itemizedlist>
				<listitem>
				<para>
					<emphasis>0</emphasis> - simple key - the key is added
					as 'key_name'.
				</para>
				</listitem>
				<listitem>
				<para>
					<emphasis>1</emphasis> - array key - the key is added
					as 'key_name[n]' - n is incremented for each key with this
					name to build an array in hash table.  In addition, an additional
					key is built to hold the total number of key in the array,
					by default key_name::size (see array_size_suffix parameter).
				</para>
				</listitem>
			</itemizedlist>
			</listitem>
			<listitem>
			<para>
				<emphasis>value type</emphasis> - the type of the key value
			</para>
			<itemizedlist>
				<listitem>
				<para>
					<emphasis>0</emphasis> - value is string.
				</para>
				</listitem>
				<listitem>
				<para>
					<emphasis>1</emphasis> - value is integer.
				</para>
				</listitem>
			</itemizedlist>
			</listitem>
			<listitem>
			<para>
				<emphasis>key value</emphasis> - string containing the value of
				the key.
			</para>
			</listitem>
			</itemizedlist>
	</section>

	</section>
	<section>
	<title>Parameters</title>
	<section id="htable.p.htable">
		<title><varname>htable</varname> (str)</title>
		<para>
		The definition of a hash table. The value of the parameter may have the
		following format:
		</para>
		<itemizedlist>
		<listitem>
		<para>
		"htname=&gt;size=_number_;autoexpire=_number_;dbtable=_string_"
		</para>
		</listitem>
		</itemizedlist>
		<para>
			The parameter can be set multiple times to get more hash tables in
			same configuration file.
		</para>
		<itemizedlist>
		<listitem>
		<para>
			<emphasis>htname</emphasis> - string specifying the name of
			the hash table. This string is used by <emphasis>$sht(...)</emphasis>
			to refer to the hash table.
		</para>
		</listitem>
		<listitem>
		<para>
			<emphasis>size</emphasis> - number specifying the size of hash
			table.  Larger value means less collisions. The number of entries
			(aka slots or buckets) in the table is 2^size. The possible range
			for this value is from 2 to 31, smaller or larger values will be
			increased to 3 (8 slots) or decreased to 14 (16384 slots).
		</para>
		</listitem>
		<listitem>
		<para>
			<emphasis>autoexpire</emphasis> -time in seconds to delete an item
			from a hash table if no update was done to it. If is missing or set
			to 0, the items won't expire.
		</para>
		</listitem>
		<listitem>
		<para>
			<emphasis>dbtable</emphasis> - name of database to be loaded at
			startup in hash table. If empty or missing, no data will be loaded.
		</para>
		</listitem>
		<listitem>
		<para>
			<emphasis>cols</emphasis> - the column names of the database table.
			They must be enclosed in quotes in order to form a valid SIP
			parameter value and be separated by comma. The first column
			corresponds to key_name. When specified, there must be at least
			two columns. If this attribute is not specified, then the global
			module parameters for column names are used. If more than one
			value columns are specified, the hash table will pack the column
			values in a comma separated string, which will be associated
			with the key (string transformation {s.select,...} can be
			used in configuration file to extract a specific column value).
			When cols attribute is present, writing back to database table
			is disabled.
			</para>
		</listitem>
		<listitem>
		<para>
			<emphasis>dbmode</emphasis> - if set to 1, the content of hash
			table is written to database table when the SIP server is stopped
			(i.e., ensure persistency over restarts). Default value is 0 (no
			write back to db table).
		</para>
		</listitem>
		<listitem>
		<para>
			<emphasis>initval</emphasis> - the integer value to be returned
			instead of $null when a requested key is not set.
		</para>
		</listitem>
		<listitem>
		<para>
			<emphasis>updateexpire</emphasis> - if set to 1 (default), the time until
			expiration of an item is reset when that item is updated.  Certain uses of
			htable may dictate that updates should not reset the expiration timeout, however,
			in which case this attribute can be set to 0.
		</para>
		</listitem>
		<listitem>
		<para>
			<emphasis>dmqreplicate</emphasis> - if set to 1, any actions (set, update, delete
			etc.) performed upon entries in this table will be replicated to other nodes (htable
			peers). Please note, module parameter <quote>enable_dmq</quote> must also be set in
			order for this to apply (see below). Default is 0 (no replication).
		</para>
		</listitem>
		</itemizedlist>
		<para>
		<emphasis>
			Default value is NULL.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>hash_size</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("htable", "htable", "a=&gt;size=4;autoexpire=7200;dbtable=htable_a;")
modparam("htable", "htable", "b=&gt;size=5;")
modparam("htable", "htable", "c=&gt;size=4;autoexpire=7200;initval=1;dmqreplicate=1;")
...
</programlisting>
		</example>
	</section>
	<section id="htable.p.db_url">
		<title><varname>db_url</varname> (str)</title>
		<para>
			The <acronym>URL</acronym> to connect to database for loading values in hash
			table at start up.
		</para>
		<para>
		<emphasis>
			Default value is NULL (do not connect).
		</emphasis>
		</para>
		<example>
		<title>Set <varname>db_url</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("htable", "db_url", "&defaultdb;")
...
</programlisting>
		</example>
	</section>
	<section id="htable.p.key_name_column">
		<title><varname>key_name_column</varname> (str)</title>
		<para>
			The name of the column containing the hash table key name.
		</para>
		<para>
		<emphasis>
			Default value is 'key_name'.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>key_name_column</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("htable", "key_name_column", "kname")
...
</programlisting>
		</example>
	</section>
	<section id="htable.p.key_type_column">
		<title><varname>key_type_column</varname> (str)</title>
		<para>
			The name of the column containing the hash table key type.
		</para>
		<para>
		<emphasis>
			Default value is 'key_type'.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>key_type_column</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("htable", "key_type_column", "ktype")
...
</programlisting>
		</example>
	</section>
	<section id="htable.p.value_type_column">
		<title><varname>value_type_column</varname> (str)</title>
		<para>
			The name of the column containing the hash table value type.
		</para>
		<para>
		<emphasis>
			Default value is 'value_type'.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>value_type_column</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("htable", "value_type_column", "vtype")
...
</programlisting>
		</example>
	</section>
	<section id="htable.p.key_value_column">
		<title><varname>key_value_column</varname> (str)</title>
		<para>
			The name of the column containing hash table key value.
		</para>
		<para>
		<emphasis>
			Default value is 'key_value'.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>key_value_column</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("htable", "key_value_column", "kvalue")
...
</programlisting>
		</example>
	</section>
	<section id="htable.p.expires_column">
		<title><varname>expires_column</varname> (str)</title>
		<para>
			The name of the column containing the expires value.
		</para>
		<para>
		<emphasis>
			Default value is 'expires'.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>expires_column</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("htable", "expires_column", "expiry")
...
</programlisting>
		</example>
	</section>
	<section id="htable.p.array_size_suffix">
		<title><varname>array_size_suffix</varname> (str)</title>
		<para>
			The suffix to be added to store the number of items in an
			array (see key type).
		</para>
		<para>
		<emphasis>
			Default value is '::size'.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>array_size_suffix</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("htable", "array_size_suffix", "-count")
...
</programlisting>
		</example>
	</section>
	<section id="htable.p.fetch_rows">
		<title><varname>fetch_rows</varname> (integer)</title>
		<para>
		How many rows to fetch at once from database.
		</para>
		<para>
		<emphasis>
			Default value is 100.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>fetch_rows</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("htable", "fetch_rows", 1000)
...
</programlisting>
		</example>
	</section>
	<section id="htable.p.timer_interval">
		<title><varname>timer_interval</varname> (integer)</title>
		<para>
		Interval in seconds to check for expired htable values.
		</para>
		<para>
		<emphasis>
			Default value is 20.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>timer_interval</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("htable", "timer_interval", 10)
...
</programlisting>
		</example>
	</section>
	<section id="htable.p.db_expires">
		<title><varname>db_expires</varname> (integer)</title>
		<para>
			If set to 1, the module will load/save the expires values of the items in
			hash table from/to database. It applies only to hash tables that
			have the auto-expires attribute defined.
		</para>
		<para>
		<emphasis>
			Default value is 0.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>db_expires</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("htable", "db_expires", 1)
...
</programlisting>
		</example>
	</section>
	<section id="htable.p.enable_dmq">
		<title><varname>enable_dmq</varname> (integer)</title>
		<para>
			If set to 1, will enable DMQ replication of actions performed upon
			entries in all tables having "dmqreplicate" parameter set. Any update
			action performed via pseudo-variables and RPC commands will be
			repeated on all other nodes. Therefore, it is important to ensure the
			table definition (size, autoexpire etc.) is identical across all instances.
		</para>
		<para>
		<emphasis>
			Important: If this parameter is enabled, the DMQ module must be loaded first - otherwise, startup will fail.
		</emphasis>
		</para>
		<para>
			Currently, values are not replicated on load from DB as it is expected
			that in these cases, all servers will load their values from the same DB.
		</para>
		<para>
		<emphasis>
			Default value is 0.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>enable_dmq</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("htable", "enable_dmq", 1)
...
</programlisting>
		</example>
	</section>
	<section id="htable.p.timer_procs">
		<title><varname>timer_procs</varname> (integer)</title>
		<para>
			If set to 1 or greater, the module will create its own timer
			processes to scan for expired items in hash tables. If set to zero,
			it will use the core timer for this task. Set it to 1 if you store
			a lot of items with autoexpire property.
		</para>
		<para>
		<emphasis>
			Default value is 0.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>timer_procs</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("htable", "timer_procs", 4)
...
</programlisting>
		</example>
	</section>
	<section id="htable.p.event_callback">
		<title><varname>event_callback</varname> (str)</title>
		<para>
			The name of the function in the kemi configuration file (embedded
			scripting language such as Lua, Python, ...) to be executed instead
			of event_route[...] blocks.
		</para>
		<para>
			The function receives a string parameter with the name of the event,
			the values can be: 'htable:mod-init', 'htable:expired:htname'
			('htname' being the name of hash table).
		</para>
		<para>
		<emphasis>
			Default value is 'empty' (no function is executed for events).
		</emphasis>
		</para>
		<example>
		<title>Set <varname>event_callback</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("htable", "event_callback", "ksr_htable_event")
...
-- event callback function implemented in Lua
function ksr_htable_event(evname)
	KSR.info("===== htable module triggered event: " .. evname .. "\n");
	return 1;
end
...
</programlisting>
		</example>
	</section>
	</section>
	<section>
	<title>Functions</title>
	<section id="htable.f.sht_print">
		<title>
		<function moreinfo="none">sht_print()</function>
		</title>
		<para>
			Dump content of hash table to L_ERR log level. Intended for debug
			purposes.
		</para>
		<para>
			This function can be used from REQUEST_ROUTE, FAILURE_ROUTE,
			ONREPLY_ROUTE, BRANCH_ROUTE.
		</para>
		<example>
		<title><function>sht_print</function> usage</title>
		<programlisting format="linespecific">
...
sht_print();
...
</programlisting>
		</example>
	</section>
	<section id="htable.f.sht_rm_name_re">
		<title>
		<function moreinfo="none">sht_rm_name_re(htable=>regexp)</function>
		</title>
		<para>
			Delete all entries in the htable that match the name against
			regular expression.
		</para>
		<para>
			This function can be used from REQUEST_ROUTE, FAILURE_ROUTE,
			ONREPLY_ROUTE, BRANCH_ROUTE.
		</para>
		<example>
		<title><function>sht_rm_name_re</function> usage</title>
		<programlisting format="linespecific">
...
sht_rm_name_re("ha=>.*");
...
</programlisting>
		</example>
	</section>
	<section id="htable.f.sht_rm_value_re">
		<title>
		<function moreinfo="none">sht_rm_value_re(htable=>regexp)</function>
		</title>
		<para>
			Delete all entries in the htable that match the value against
			regular expression.
		</para>
		<para>
			This function can be used from REQUEST_ROUTE, FAILURE_ROUTE,
			ONREPLY_ROUTE, BRANCH_ROUTE.
		</para>
		<example>
		<title><function>sht_rm_value_re</function> usage</title>
		<programlisting format="linespecific">
...
sht_rm_value_re("ha=>.*");
...
</programlisting>
		</example>
	</section>
	<section id="htable.f.sht_rm_name">
		<title>
		<function moreinfo="none">sht_rm_name(htable, op, val)</function>
		</title>
		<para>
			Delete all entries in the htable that match the name against
			the val parameter.
		</para>
		<para>
			The op parameter can be:
		</para>
		<itemizedlist>
		<listitem>
		<para>
			<emphasis>re</emphasis> - match the val parameter as regular
			expression.
		</para>
		</listitem>
		<listitem>
		<para>
			<emphasis>sw</emphasis> - match the val parameter as 'starts
			with'.
		</para>
		</listitem>
		</itemizedlist>
		<para>
			All parameters can be static strings or contain variables.
		</para>
		<para>
			This function can be used from ANY_ROUTE.
		</para>
		<example>
		<title><function>sht_rm_name</function> usage</title>
		<programlisting format="linespecific">
...
sht_rm_name("ha", "re", ".*");
...
</programlisting>
		</example>
	</section>
	<section id="htable.f.sht_rm_value">
		<title>
		<function moreinfo="none">sht_rm_value(htable, op, val)</function>
		</title>
		<para>
			Delete all entries in the htable that match the value against
			the val parameter.
		</para>
		<para>
			The op parameter can be:
		</para>
		<itemizedlist>
		<listitem>
		<para>
			<emphasis>re</emphasis> - match the val parameter as regular
			expression.
		</para>
		</listitem>
		<listitem>
		<para>
			<emphasis>sw</emphasis> - match the val parameter as 'starts
			with'.
		</para>
		</listitem>
		</itemizedlist>
		<para>
			All parameters can be static strings or contain variables.
		</para>
		<para>
			This function can be used from ANY_ROUTE.
		</para>
		<example>
		<title><function>sht_rm_value</function> usage</title>
		<programlisting format="linespecific">
...
sht_rm_value("ha", "re", ".*");
...
</programlisting>
		</example>
	</section>
	<section id="htable.f.sht_reset">
		<title>
		<function moreinfo="none">sht_reset(htable)</function>
		</title>
		<para>
			Delete all entries in the htable. The name of the hash table
			can be a dynamic string with variables.
		</para>
		<para>
			This function can be used from ANY_ROUTE.
		</para>
		<example>
		<title><function>sht_reset</function> usage</title>
		<programlisting format="linespecific">
...
sht_reset("ha$var(x)");
...
</programlisting>
		</example>
	</section>
	<section id="htable.f.sht_lock">
		<title>
		<function moreinfo="none">sht_lock(htable=>key)</function>
		</title>
		<para>
			Lock the slot in htable corresponding to the key item. Note that
			the locking is re-entrant for the process, therefore the lock
			and unlock should be done by the same process.
		</para>
		<para>
			This function can be used from ANY_ROUTE.
		</para>
		<example>
		<title><function>sht_lock</function> usage</title>
		<programlisting format="linespecific">
...
sht_lock("ha=>test");
...
</programlisting>
		</example>
	</section>
	<section id="htable.f.sht_unlock">
		<title>
		<function moreinfo="none">sht_unlock(htable=>key)</function>
		</title>
		<para>
			Unlock the slot in htable corespoding to the key item. Note that
			the locking is re-entrant for the process, therefore the lock
			and unlock should be done by the same process.
		</para>
		<para>
			This function can be used from ANY_ROUTE.
		</para>
		<example>
		<title><function>sht_unlock</function> usage</title>
		<programlisting format="linespecific">
...
sht_lock("ha=>test");
$sht(ha=>test) = $sht(ha=>test) + 10;
sht_unlock("ha=>test");
...
</programlisting>
		</example>
	</section>
	<section id="htable.f.sht_iterator_start">
		<title>
		<function moreinfo="none">sht_iterator_start(iname, hname)</function>
		</title>
		<para>
			Start an iterator for hash table named by the value of parameter
			hname. The parameter iname is used to identify the iterator. There
			can be up to 4 iterators at the same time, with different name.
		</para>
		<para>
			Both parameters can be dynamic strings with variables.
		</para>
		<para>
			IMPORTANT: the slot of the hash table is left locked when
			retrieving in item. Therefore be sure you do not update the
			content of the hash table in between sht_iterator_start()
			and sht_iterator_end(), because it may end up in dead lock.
		</para>
		<para>
			This function can be used from ANY_ROUTE.
		</para>
		<example>
		<title><function>sht_iterator_start</function> usage</title>
		<programlisting format="linespecific">
...
sht_iterator_start("i1", "h1");
...
</programlisting>
		</example>
	</section>
	<section id="htable.f.sht_iterator_end">
		<title>
		<function moreinfo="none">sht_iterator_end(iname)</function>
		</title>
		<para>
			Close the iterator identified by iname parameter and release
			the hash table slot aquired by the iterator. The iname value
			must be the same used for sht_iterator_start().
		</para>
		<para>
			The parameter can be dynamic string with variables.
		</para>
		<para>
			This function can be used from ANY_ROUTE.
		</para>
		<example>
		<title><function>sht_iterator_end</function> usage</title>
		<programlisting format="linespecific">
...
sht_iterator_end("i1");
...
</programlisting>
		</example>
	</section>
	<section id="htable.f.sht_iterator_next">
		<title>
		<function moreinfo="none">sht_iterator_next(iname)</function>
		</title>
		<para>
			Move the iterator to the next item in hash table. It must
			be called also after sht_iterator_start() to get the first
			item in the hash table. Items are returned as they are found
			in the hash table slot, starting with the first slot.
		</para>
		<para>
			The return code is false when there is no (more) item in the
			hash table.
		</para>
		<para>
			The item name and value are accessible via variables:
			$shtitkey(iname) and $shtitval(iname).
		</para>
		<para>
			The parameter can be dynamic string with variables.
		</para>
		<para>
			This function can be used from ANY_ROUTE.
		</para>
		<example>
		<title><function>sht_iterator_next</function> usage</title>
		<programlisting format="linespecific">
...
    sht_iterator_start("i1", "h1");
    while(sht_iterator_next("i1")) {
        xlog("h1[$shtitkey(i1)] is: $shtitval(i1)\n");
    }
    sht_iterator_end("i1");
...
</programlisting>
		</example>
	</section>
	</section>
		<section>
		<title>Exported pseudo-variables</title>
		<itemizedlist>
			<listitem><para>
				<emphasis>$sht(htable=>key)</emphasis>
			</para></listitem>
			<listitem><para>
				<emphasis>$shtex(htable=>key)</emphasis>
			</para></listitem>
			<listitem><para>
				<emphasis>$shtcn(htable=>key)</emphasis>
			</para></listitem>
			<listitem><para>
				<emphasis>$shtcv(htable=>key)</emphasis>
			</para></listitem>
			<listitem><para>
				<emphasis>$shtinc(htable=>key)</emphasis>
			</para></listitem>
			<listitem><para>
				<emphasis>$shtitkey(iname)</emphasis>
			</para></listitem>
			<listitem><para>
				<emphasis>$shtitval(iname)</emphasis>
			</para></listitem>
			<listitem><para>
				<emphasis>$shtrecord(attribute)</emphasis>
			</para></listitem>
		</itemizedlist>
		<para>
		Exported pseudo-variables are documented at &kamwikilink;.
		</para>
	</section>
	<section>
        <title>RPC Commands</title>
        <section id="htable.rpc.get">
                <title>
                <function moreinfo="none">htable.get htable key</function>
                </title>
                <para>
					Lists one value in a hash table
                </para>
                <para>
                Name: <emphasis>htable.get</emphasis>
                </para>
                <para>Parameters:</para>
                <itemizedlist>
                        <listitem><para>htable : Name of the hash table to dump</para>
                        </listitem>
                        <listitem><para>key : Key name of the hash table value to dump</para>
                        </listitem>

                </itemizedlist>
                <para>
                Example:
                </para>
<programlisting  format="linespecific">
...
# Dump $sht(students=>alice)
kamcmd htable.get students alice

# Dump first entry in array key course $sht(students=>course[0])
kamcmd htable.get students course[0]
...
</programlisting>
	</section>
        <section id="htable.rpc.delete">
                <title>
                <function moreinfo="none">htable.delete htable key</function>
                </title>
                <para>
					Delete one value in a hash table
                </para>
                <para>
                Name: <emphasis>htable.delete</emphasis>
                </para>
                <para>Parameters:</para>
                <itemizedlist>
                        <listitem><para>htable : Name of the hash table to delete</para>
                        </listitem>
                        <listitem><para>key : Key name of the hash table value to delete</para>
                        </listitem>

                </itemizedlist>
                <para>
                Example:
                </para>
<programlisting  format="linespecific">
...
# Delete $sht(students=>alice)
kamcmd htable.delete students alice

# Delete first entry in array key course $sht(students=>course[0])
kamcmd htable.delete students course[0]
...
</programlisting>
	</section>
       <section id="htable.rpc.sets">
                <title>
                <function moreinfo="none">htable.sets htable key value</function>
                </title>
                <para>
					Set an item in hash table to string value.
                </para>
                <para>
                Name: <emphasis>htable.sets</emphasis>
                </para>
                <para>Parameters:</para>
                <itemizedlist>
                        <listitem><para>htable : Name of the hash table</para>
                        </listitem>
                        <listitem><para>key : Key name in the hash table</para>
                        </listitem>
                        <listitem><para>Value : String value for the item</para>
                        </listitem>

                </itemizedlist>
                <para>
                Example:
                </para>
<programlisting  format="linespecific">
...
# Set $sht(test=>x) as string
kamcmd htable.sets test x abc

# Set firsti entry in array key x $sht(test=>x[0]) as string
kamcmd htable.sets test x[0] abc
...
</programlisting>
	</section>
       <section id="htable.rpc.seti">
                <title>
                <function moreinfo="none">htable.seti htable key value</function>
                </title>
                <para>
					Set an item in hash table to integer value.
                </para>
                <para>
                Name: <emphasis>htable.seti</emphasis>
                </para>
                <para>Parameters:</para>
                <itemizedlist>
                        <listitem><para>htable : Name of the hash table</para>
                        </listitem>
                        <listitem><para>key : Key name in the hash table</para>
                        </listitem>
                        <listitem><para>Value : Integer value for the item</para>
                        </listitem>

                </itemizedlist>
                <para>
                Example:
                </para>
<programlisting  format="linespecific">
...
# Set $sht(test=>x) as integer
kamcmd htable.seti test x 123

# Set firsti entry in array key x $sht(test=>x[0]) as integer
kamcmd htable.sets test x[0] 123
...
</programlisting>
	</section>
        <section id="htable.rpc.dump">
                <title>
                <function moreinfo="none">htable.dump htable</function>
                </title>
                <para>
		Lists all the values in a hash table
                </para>
                <para>
                Name: <emphasis>dhtable.dump</emphasis>
                </para>
                <para>Parameters:</para>
                <itemizedlist>
                        <listitem><para>htable : Name of the hash table to dump</para>
                        </listitem>

                </itemizedlist>
                <para>
                Example:
                </para>
<programlisting  format="linespecific">
...
kamcmd htable.dump ipban
...
</programlisting>
	</section>
        <section id="htable.rpc.reload">
                <title>
                <function moreinfo="none">htable.reload htable</function>
                </title>
                <para>
		Reload hash table from database.
                </para>
                <para>
                Name: <emphasis>dhtable.reload</emphasis>
                </para>
                <para>Parameters:</para>
                <itemizedlist>
                        <listitem><para>htable : Name of the hash table to reload</para>
                        </listitem>

                </itemizedlist>
                <para>
                Example:
                </para>
<programlisting  format="linespecific">
...
kamcmd htable.reload ipban
...
</programlisting>
	</section>
        <section id="htable.rpc.listTables">
                <title>
                <function moreinfo="none">htable.listTables</function>
                </title>
                <para>
		Lists all defined tables
                </para>
                <para>
                Name: <emphasis>htable.listTables</emphasis>
                </para>
                <para>Parameters:</para>
                <itemizedlist>
                        <listitem><para>None</para>
                        </listitem>

                </itemizedlist>
                <para>
                Example:
                </para>
<programlisting  format="linespecific">
...
kamcmd htable.listTables
...
</programlisting>
	</section>
    <section id="htable.rpc.stats">
          <title>
                <function moreinfo="none">htable.stats</function>
          </title>
          <para>
			  Get statistics for hash tables - name, number of slots,
			  number of items, max number of items per slot, min number
			  of items per slot.
          </para>
                <para>
                Name: <emphasis>htable.stats</emphasis>
                </para>
                <para>Parameters:</para>
                <itemizedlist>
                        <listitem><para>None</para>
                        </listitem>

                </itemizedlist>
                <para>
                Example:
                </para>
<programlisting  format="linespecific">
...
kamcmd htable.stats
...
</programlisting>
	</section>

	</section><!-- RPC commands -->

	<section>
	<title>Event routes</title>
	<section>
		<title>
		<function moreinfo="none">htable:mod-init</function>
		</title>
		<para>
			When defined, the module calls event_route[htable:mod-init] after
			all modules have been initialized. A typical use case is to
			initialise items in hash tables. The event route is executed only
			once, after core and module initialization, but before &kamailio; forks any
			child processes.
		</para>
<programlisting  format="linespecific">
...
event_route[htable:mod-init] {
    $sht(a=>x) = 1;
}
...
</programlisting>
	</section>
	<section>
		<title>
		<function moreinfo="none">htable:expired:&lt;table&gt;</function>
		</title>
		<para>
			When defined, the module calls event_route[htable:expired:&lt;table&gt;]
			when an entry in the given table expires. In this event route, the key and value
			of the expired record are available with the $shtrecord(key) and $shtrecord(value)
			pseudo-variables.
		</para>
<programlisting  format="linespecific">
...

event_route[htable:expired:mytable] {
    xlog("mytable record expired $shtrecord(key) => $shtrecord(value)\n");
}
...
</programlisting>
	</section>
	</section>

</chapter>

