1. Dbtext Module

Daniel-Constantin Mierla

   FhG FOKUS

   Copyright Â© 2003, 2004 FhG FOKUS
     __________________________________________________________________

   1.1. Overview

        1.1.1. Design of Dbtext Engine
        1.1.2. Internal Format of a Dbtext Table

   1.2. Installation And Running

        1.2.1. Using Dbtext With Basic SER Configuration

1.1. Overview

   The module implements a simplified database engine based on text files.
   It can be used by SER DB interface instead of other database module
   (like MySQL).

   The module is meant for use in demos or small devices that do not
   support other DB modules. It keeps everything in memory and if you deal
   with large amount of data you may run quickly out of memory. Also, it
   has not implemented all standard database facilities (like order by),
   it includes minimal functionality to work properly (who knows ?!?) with
   SER.

1.1.1. Design of Dbtext Engine

   The dbtext database system architecture:
     * A database is represented by a directory on the local file system.

Note
       When you use "dbtext" in SER, the database URL for modules must be
       the path to the directory where the table-files are located,
       prefixed by "dbtext://", e.g., "dbtext:///var/dbtext/ser". If there
       is no "/" after "dbtext://" then "CFG_DIR/" is inserted at the
       beginning of the database path. So, either you provide an absolute
       path to database directory or a relative one to "CFG_DIR"
       directory.
     * A table is represented by a text file inside database directory.

1.1.2. Internal Format of a Dbtext Table

   First line is the definition of the columns. Each column must be
   declared as follows:
     * the name of column must not include white spaces.
     * the format of a column definition is: name(type,attr).
     * between two column definitions must be a white space, e.g.,
       "first_name(str) last_name(str)".
     * the type of a column can be:
          + int - integer numbers.
          + double - real numbers with two decimals.
          + str - strings with maximum size of 4KB.
     * a column can have one of the attributes:
          + auto - only for 'int' columns, the maximum value in that
            column is incremented and stored in this field if it is not
            provided in queries.
          + null - accept null values in column fields.
          + if no attribute is set, the fields of the column cannot have
            null value.
     * each other line is a row with data. The line ends with "\n".
     * the fields are separated by ":".
     * no value between two ':' (or between ':' and start/end of a row)
       means "null" value.
     * next characters must be escaped in strings: "\n", "\r", "\t", ":".
     * 0 - The zero value must be escaped too.

   Example 1. Sample of a dbtext table
...
id(int,auto) name(str) flag(double) desc(str,null)
1:nick:0.34:a\tgood\:friend
2:cole:-3.75:colleague3:bob:2.50:
...

   Example 2. Minimal SER location dbtext table definition
...
username(str) contact(str) expires(int) q(double) callid(str) cseq(int)
...

   Example 3. Minimal SER subscriber dbtext table example
...
username(str) password(str) ha1(str) domain(str) ha1b(str)
suser:supasswd:xxx:iptel.org:xxx
...

1.2. Installation And Running

   Compile the module and load it instead of mysql or other DB modules.

Note

   When you use dbtext in SER, the database URL for modules must be the
   path to the directory where the table-files are located, prefixed by
   "dbtext://", e.g., "dbtext:///var/dbtext/ser". If there is no "/" after
   "dbtext://" then "CFG_DIR/" is inserted at the beginning of the
   database path. So, either you provide an absolute path to database
   directory or a relative one to "CFG_DIR" directory.

   Example 4. Load the dbtext module
...
loadmodule "/path/to/ser/modules/dbtext.so"
...
modparam("module_name", "db_url", "dbtext:///path/to/dbtext/database")
...

1.2.1. Using Dbtext With Basic SER Configuration

   Here are the definitions for most important table as well as a basic
   configuration file to use dbtext with SER. The table structures may
   change in time and you will have to adjust next examples.

   You have to populate the table 'subscriber' by hand with user profiles
   in order to have authentication. To use with the given configuration
   file, the table files must be placed in the '/tmp/serdb' directory.

   Example 5. Definition of 'subscriber' table (one line)
...
username(str) domn(str) password(str) first_name(str) last_name(str)
phone(str) email_address(str) datetime_created(int)
datetime_modified(int) confirmation(str) flag(str)
sendnotification(str) greeting(str) ha1(str) ha1b(str)
perms(str) allow_find(str) timezone(str,null) rpid(str,null)
uuid(str,null)
...

   Example 6. Definition of 'location' and 'aliases' tables (one line)
...
username(str) domain(str,null) contact(str,null) expires(int,null)
q(double,null) callid(str,null) cseq(int,null)
last_modified(str) replicate(int,null) state(int,null)
flags(int) user_agent(str) received(str)
...

   Example 7. Definition of 'version' table and sample records
...
table_name(str) table_version(int) subscriber:3 location:6 aliases:6
...

   Example 8. Configuration file
#
# $Id$
#
# simple quick-start config script with dbtext
#

# ----------- global configuration parameters ------------------------

#debug=9         # debug level (cmd line: -dddddddddd)
#fork=yes
#log_stderror=no        # (cmd line: -E)

check_via=no    # (cmd. line: -v)
dns=no          # (cmd. line: -r)
rev_dns=no      # (cmd. line: -R)
children=4

listen=10.100.100.1
port=5060

fifo="/tmp/ser_fifo"

alias=alpha.org

# ------------------ module loading ----------------------------------

# use dbtext database
loadmodule "../sip_router/modules/dbtext/dbtext.so"

loadmodule "../sip_router/modules/sl/sl.so"
loadmodule "../sip_router/modules/tm/tm.so"
loadmodule "../sip_router/modules/rr/rr.so"
loadmodule "../sip_router/modules/maxfwd/maxfwd.so"
loadmodule "../sip_router/modules/usrloc/usrloc.so"
loadmodule "../sip_router/modules/registrar/registrar.so"
loadmodule "../sip_router/modules/textops/textops.so"

# modules for digest authentication
loadmodule "../sip_router/modules/auth/auth.so"
loadmodule "../sip_router/modules/auth_db/auth_db.so"

# ----------------- setting module-specific parameters ---------------

# -- usrloc params --

# use dbtext database for persistent storage
modparam("usrloc", "db_mode", 2)
modparam("usrloc|auth_db", "db_url", "dbtext:///tmp/serdb")

# -- auth params --
#
modparam("auth_db", "calculate_ha1", 1)
modparam("auth_db", "password_column", "password")
modparam("auth_db", "user_column", "username")
modparam("auth_db", "domain_column", "domain")

# -- rr params --
# add value to ;lr param to make some broken UAs happy
modparam("rr", "enable_full_lr", 1)

# -------------------------  request routing logic -------------------

# main routing logic

route{
    # initial sanity checks -- messages with
    # max_forwards==0, or excessively long requests
    if (!mf_process_maxfwd_header("10")) {
        sl_send_reply("483","Too Many Hops");
        break;
    };
    if (msg:len >=  max_len ) {
        sl_send_reply("513", "Message too big");
        break;
    };

    # we record-route all messages -- to make sure that
    # subsequent messages will go through our proxy; that's
    # particularly good if upstream and downstream entities
    # use different transport protocol
    if (!method=="REGISTER") record_route();

    # subsequent messages withing a dialog should take the
    # path determined by record-routing
    if (loose_route()) {
        # mark routing logic in request
        append_hf("P-hint: rr-enforced\r\n");
        route(1);
        break;
    };

    if (!uri==myself) {
        # mark routing logic in request
        append_hf("P-hint: outbound\r\n");
        route(1);
        break;
    };

    # if the request is for other domain use UsrLoc
    # (in case, it does not work, use the following command
    # with proper names and addresses in it)
    if (uri==myself) {
        if (method=="REGISTER") {
            # digest authentication
            if (!www_authorize("", "subscriber")) {
                www_challenge("", "0");
                break;
            };

            save("location");
            break;
        };

        lookup("aliases");
        if (!uri==myself) {
            append_hf("P-hint: outbound alias\r\n");
            route(1);
            break;
        };

        # native SIP destinations are handled using our USRLOC DB
        if (!lookup("location")) {
            sl_send_reply("404", "Not Found");
            break;
        };
    };
    append_hf("P-hint: usrloc applied\r\n");
    route(1);
}

route[1]
{
    # send it out now; use stateful forwarding as it works reliably
    # even for UDP2TCP
    if (!t_relay()) {
        sl_reply_error();
    };
}
