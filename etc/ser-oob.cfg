#
# $Id$
#
#
# Applicability of this Configuration File
# ----------------------------------------
#
# This is default SER script as used for example at the iptel.org
# SIP service; it can deal with NATs, terminate calls to a PSTN
# gateway, and it implements a couple of basic signaling features
# (few types of call forwarding). In this scenario you may have
# multiple SIP proxies sharing one database for accessing provisioned
# data, which are maintained for example using serweb. The proxy
# servers also share write-access to user location database (and
# keeps a full cache of all usrloc entries synchronized using
# multicast).
# 
# If you look for a simpler version with a lot less dependencies
# please refer to the ser-basic.cfg file in your SER distribution.
#
# Requirements: 
# ---------------
# running DB, running RTP proxy, one public IP address
# for SIP service, one private IP address for administrative purposes;
# optional: IP address of a PSTN gateway
#
# HOWTOs:
# ---------
# To get this config running you need to execute the following commands
# with the new serctl (the capital word are just place holders)
# - ser_ctl domain add DOMAINNAME
# - ser_ctl user add USERNAME@DOMAINNAME -p PASSWORD
# If you want to have PID header for your user
# - ser_attr add uid=UID asserted_id="PID"
# If you want to have gateway support
# - ser_db add attr_types name=gw_ip rich_type=string raw_type=2 description="The gateway IP for the default ser.cfg" default_flags=33
# - ser_attr add global gw_ip=GATEWAY-IP
#  Alternatively you can use serweb to set all the values above.
#
# Users with permission to call PSTN using this script must have
# the $gw_acl attribute set properly, and shall have $asserted_id
# set to indicate their caller-id for calls to PSTN. For inbound
# calls from PSTN, additional aliases may be also set.
#
# Warning:
# -----------
# Note: if this file is installed on Debian from package 'ser-oob' then some options
# in this configuration file may be set by post-installation script, according to values
# entered by user at installation time in debconf configuration.
# These values are then applied automatically to this file each time the 'ser-oob' package
# is upgraded or reconfigured by calling 'dpkg-reconfigure ser-oob'.
# The parts of this configuration file that may be altered by debconf are enclosed
# between '#DEBCONF-something-START' and '#DEBCONF-something-END' comment marks. Please
# don't remove them.
#
#
# TODO (Future possible improvements):
# ---------------------------------------
# * protocol tuning
#   - AVP-based diversion for call-forwarding (as opposed to specialized module)
#   - add Date header in 200s to REGISTERs (to be packaged with NTP!)
# * more security: 
#   - pike/rate-limit
#   - identity
#   - TLS
#   - permissions
#   - Re-name all internal headers so that they start with a common prefix, such
#     as P-SER and then wipe all such headers from requests received from 
#     untrusted sources, such as the user agents or foreign proxy servers
# * refined DB use (e.g., flatstore for acc)
# * miscellanous:
#  - dialog module for monitoring purposes
#  - more extensive logging using xlog (controlled by gflags/gAVPs)
# * leveraging 2.1 features:
#  - removal of private IP address (it takes a multicast-specific 
#    command which will allow OS to determine source IP address)
#  - timer route: 
#     * don't use exec (it takes domain.reload as script command)
#     * compare last-stored timestamp with current timestamp (it takes 
#       assignment of gAVPs)
#     * check multicast REGISTERs for their TTL (this is a simple and
#       effective security check to prevent remote multicast messages
#       to damage our traffic)
#  - numerous fine-tuning parameters which are only available in 2.1 
#   (mlock_pages, dns_try_naptr, etc.)
#  - better support for preloaded routes with domain name
#
# Security considerations:
# ------------------------
# the script has been tested against security leaks, but it comes
# under terms of GPL "as is" without any warranties; better check
# yourself that:
# - IP based authentication of PSTN gateway and multicast REGISTERs 
#   is compliant to your network setup and security policy
# - mutliple gateway IPs can't be provisioned as security checks
#   are applied only to one
#
# Licensing
# ----------
# Copyright (C) 2005-2008 iptelorg GmbH
# This file is part of SER, a free SIP server. It is available under the
# terms of the  GNU General Public License.
# Numerous folks have contributed to this file, including but not limited
# to Andrei, Jan, Jiri, Michal, Miklos, Nils
#
#
# .... that's it, enough of yadiyada, here the real file config begins!


# ----------- global configuration parameters ------------------------

#debug=3         # debug level (cmd line: -ddd)
#memdbg=10 # memory debug log level
#memlog=10 # memory statistics log level
#log_facility=LOG_LOCAL0 # sets the facility used for logging (see syslog(3))

#DEBCONF-SERVERID-START
server_id=0
#DEBCONF-SERVERID-END

/* Uncomment these lines to enter debugging mode 
fork=no
log_stderror=yes
*/

check_via=no    # (cmd. line: -v)
dns=no          # (cmd. line: -r)
rev_dns=no      # (cmd. line: -R)
#port=5060
#children=4
#user=ser
#group=ser
#disable_core=yes #disables core dumping
open_files_limit=20480 # sets the open file descriptors limit
#mhomed=yes  # usefull for multihomed hosts, small performance penalty
# be conservative about enabling TCP -- it can degrade performance a lot
disable_tcp=no
#tcp_accept_aliases=yes # accepts the tcp alias via option (see NEWS)
# ignore user=phone in request-URIs -- otherwise these URIs would be
# interpreted as equivalent to TEL URIs, and their lookup would fail
# in URI database
phone2tel=no

reply_to_via=no
# public IP address
#DEBCONF-LISTEN-START
listen=127.0.0.1
#DEBCONF-LISTEN-END
# sip.mcast.net for REGISTER replication
listen=224.0.1.75
# administrative interface -- needed for example for multicast source
# or XML-RPC
#DEBCONF-LISTEN_ADMIN-START
listen=udp:127.0.0.1
#DEBCONF-LISTEN_ADMIN-END

# ------------------- misc params -------------------------------------
# ser 2.1 only
mlock_pages=yes
shm_force_alloc=yes
real_time=7


# ------------------- DNS params -------------------------------------
# (see doc/dns.txt for more details)
# minimum timeouts 
dns_retr_time=1
dns_retr_no=1
dns_servers_no=1
dns_use_search_list=no
dns_try_ipv6=no
# dns cache & failover
use_dns_cache=on
use_dns_failover=on
# dns_cache_flags=0
dns_cache_negative_ttl=300
dns_cache_min_ttl=60
dns_cache_max_ttl=86400 # 1 day
dns_cache_mem=2048 # 2 MB
dns_cache_gc_interval=60  # garbage collection every minute
# ser 2.1 specific options
# dns_try_naptr=yes
# dns_srv_lb=yes  # srv based load balancing
# dns_udp_pref=3  # prefer udp (when resolving naptr record)
# dns_tcp_pref=2  # if no udp availbale accept tcp (for naptr)
# dns_tls_pref=-1 # ignore / don't accept tls (for naptr)
# dns_cache_delete_nonexpired=no

# ------------------- blacklist params -------------------------------------
# (see doc/dst_blacklist.txt for more details)

use_dst_blacklist=on
dst_blacklist_mem=1024 # 1 MB
dst_blacklist_expire=300  # blacklist default time
dst_blacklist_gc_interval=150 # 2.5 min
# for ser 2.1 to the above add tm blst_503* parameters and/or use the 
# blst module (see NEWS)

# ------------------- tcp params -------------------------------------
# (see NEWS for more details)
tcp_connection_lifetime=3600
#tcp_max_connections=10240  # default is 2048
tcp_connect_timeout=1

# -------------------- custom parameters ----------------------------
# These parameters can be modified runtime via RPC interface,
# read the documentation of cfg_rpc module!
#
# Session Timer parameters, RFC 4028
#
# default session interval value used by the proxy if the UAC does not support
# session timer. Set it to "0" to disable session timer proxy support
session_timer.default = "1800" desc "default session interval (in s)"
#
# minimum session interval value accepted by the proxy,
# it must not be less than 90 seconds
session_timer.min_se = "90" desc "minimum session interval (in s)"

 
# ------------------ module loading ----------------------------------

loadpath "/usr/lib/ser/modules"

# load a SQL database for authentication, domains, user AVPs etc.
loadmodule "mysql"
#loadmodule "postgres"

loadmodule "sl"
loadmodule "tm"
loadmodule "rr"
loadmodule "maxfwd"
loadmodule "usrloc"
loadmodule "registrar"
loadmodule "xlog"
loadmodule "textops"
loadmodule "ctl"
loadmodule "auth"
loadmodule "auth_db"
loadmodule "gflags"
loadmodule "domain"
loadmodule "uri_db"
loadmodule "avp"
loadmodule "avp_db"
loadmodule "acc_db"
#loadmodule "xmlrpc"
loadmodule "options"
loadmodule "sanity"
loadmodule "nathelper"
loadmodule "uri"
loadmodule "speeddial"
loadmodule "timer"
loadmodule "db_ops"
loadmodule "exec"
loadmodule "cfg_rpc"
loadmodule "eval"

# ----------------- setting script FLAGS -----------------------------
flags
  FLAG_ACC            : 1, # this request will be recorded by ACC
  FLAG_FAILUREROUTE   : 2, # we are operating from the failure route
  FLAG_NAT            : 3, # the UAC is behind a NAT
  FLAG_REPL_ENABLED   : 4, # REGISTER replication is enabled if set
  FLAG_TOTAG          : 5,
  FLAG_PSTN_ALLOWED   : 6, # the user is allowed to use the PSTN
  FLAG_DONT_RM_CRED   : 7, # do not remove the credentials
  FLAG_AUTH_OK        : 8, # authentication succeeded
  FLAG_SERWEB_RSVD1   : 9, # bit reserved for use with serweb
  FLAG_SERWEB_RSVD2   : 10, # bit reserved for use with serweb
  FLAG_SESSIONTIMER   : 11, # indicates that the UAC supports Session Timer
  FLAG_RR_DONE        : 12, # the request got already one RR header
  FLAG_RTP_PROXY      : 13; # the RTP proxy is turned on

avpflags
  dialog_cookie;        # handled by rr module

# ----------------- setting module-specific parameters ---------------

# specify the path to you database here
#DEBCONF-DBURL-START
modparam("speeddial|auth_db|usrloc|domain|uri_db|gflags|avp_db|db_ops", "db_url", "mysql://ser:heslo@127.0.0.1/ser")
#DEBCONF-DBURL-END

# specify the path to your database for accounting
#DEBCONF-DBURLACC-START
modparam("acc_db", "db_url", "mysql://ser:heslo@127.0.0.1/ser")
#DEBCONF-DBURLACC-END

# -- usrloc params --

# db_mode 0 -- memory cached, 1 -- write thru, 2 -- delayed write
# 1 is generally safer than 2 ... 2 can help to survive peaks in load
# however it creates delayed peaks that can impair request-processing
# latency later (it would have to be re-redesigned more lock-free to
# avoid it)
#DEBCONF-DBMODE-START
modparam("usrloc", "db_mode", 1)
#DEBCONF-DBMODE-END
# don't delete expired records from database on a per-contact basis -- that
# results in bulky DB operations and can lead to synchronization issues
# in server farm when for a time a server doesn't obtain re-reregistrations
modparam("usrloc","db_skip_delete",1)

# -- registrar params
# maximum expires time, forces users to re-register every 10 min.
modparam("registrar", "max_expires", 600)
# minimum expires time, even if tried, clients cannot get registered
# for a shorter time than this
modparam("registrar", "min_expires", 240)

# identify natted contacts using a flag
modparam("registrar", "load_nat_flag", "FLAG_NAT")
modparam("registrar", "save_nat_flag", "FLAG_NAT")

# maximum number of contacts
modparam("registrar", "max_contacts", 10)

# -- auth params --
#modparam("auth_db", "calculate_ha1", yes)
#modparam("auth_db", "password_column", "password")
# minimize replay-attack window
modparam("auth", "nonce_expire", 10)

# Enable/disable extra authentication checks using the following modparams.
# The values are: 1:Request-URI, 2:Call-ID, 4: From tag, 8:source IP
# The options are disabled by default.

# For REGISTER requests we hash the Request-URI, Call-ID, and source IP of the
# request into the nonce string. This ensures that the generated credentials
# cannot be used with another registrar, user agent with another source IP
# address or Call-ID. Note that user agents that change Call-ID with every
# REGISTER message will not be able to register if you enable this.
#modparam("auth", "auth_checks_register", 11)

# For dialog-establishing requests (such as the original INVITE, OPTIONS, etc)
# we hash the Request-URI and source IP. Hashing Call-ID and From tags takes
# some extra precaution, because these checks could render some UA unusable.
#modparam("auth", "auth_checks_no_dlg", 9)

# For mid-dialog requests, such as re-INVITE, we can hash source IP and
# Request-URI just like in the previous case. In addition to that we can hash
# Call-ID and From tag because these are fixed within a dialog and are
# guaranteed not to change. This settings effectively restrict the usage of
# generated credentials to a single user agent within a single dialog.
#modparam("auth", "auth_checks_in_dlg", 15)

# deal with client's who can't do qop properly
modparam("auth", "qop", "")
#DEBCONF-AUTHSECRET-START
modparam("auth", "secret", "aqwedrftredswqwddcft")
#DEBCONF-AUTHSECRET-END


# -- rr params --
# add value to ;lr param to make some broken UAs happy
modparam("rr", "enable_full_lr", 1)
#
# limit the length of the AVP cookie to only necessary ones
modparam("rr", "cookie_filter", "(account|uac_nat|stimer)")
#
# you probably do not want that someone can simply read and change
# the AVP cookie in your Routes, thus should really change this
# secret value below
modparam("rr", "cookie_secret", "sgsatewgdbsnmpoiewh")

# ftag may be used to easily determine if a BYE is coming from
# caller or callee, but here we prefer shorter messages
modparam("rr", "append_fromtag", 0)

# -- gflags params --
# load the global AVPs
# here we load global AVPs such as PSTN GW IP address; this can
# be manipulated using ser_attr
modparam("gflags", "load_global_attrs", 1)

# -- domain params --
# load the domain AVPs
modparam("domain", "load_domain_attrs", 1)

# -- ctl params --
# by default ctl listens on unixs:/tmp/ser_ctl if no other address is
# specified in modparams; this is also the default for sercmd
modparam("ctl", "binrpc", "unixs:/tmp/ser_ctl")
# listen on the "standard" fifo for backward compatibility
modparam("ctl", "fifo", "fifo:/tmp/ser_fifo")
# listen on tcp, localhost
#modparam("ctl", "binrpc", "tcp:localhost:2046")

# -- acc_db params --
# failed transactions (=negative responses) should be logged to
modparam("acc_db", "failed_transactions", 1)

# comment the next line if you dont want to have accouting to DB
modparam("acc_db", "log_flag", "FLAG_ACC")

# if you would like to customize your CDRs, do it here....
#modparam("acc_db", "attrs", "$f.sop_billing_category,$f.isPrepaidCustomer,$f.sop_cf_orig_uid")

# -- tm params --
# uncomment the following line if you want to avoid that each new reply
# restarts the resend timer (see INBOUND route below)
modparam("tm", "restart_fr_on_each_reply", 0)

# -- xmlrpc params --
# using a sub-route from the module is a lot safer then relying on the
# request method to distinguish HTTP from SIP
#modparam("xmlrpc", "route", "RPC");

# -- nathelper params --
# RTP-Proxy
#DEBCONF-RTTPPROXY-START
modparam("nathelper", "rtpproxy_sock", "udp:127.0.0.1:22222")
#DEBCONF-RTTPPROXY-END
# TCP keepalives as simple as CRLF
modparam("nathelper", "natping_crlf", 0)
#DEBCONF-NATPING_INTERVAL-START
modparam("nathelper", "natping_interval", 15)
#DEBCONF-NATPING_INTERVAL-END
modparam("nathelper", "ping_nated_only", 1)
# if this option is not set, simple 4-bytes ping is sent
modparam("nathelper", "natping_method", "OPTIONS")
#temporary statefull natping test (only in future versions)
#modparam("nathelper", "natping_stateful", 1)

# -- exec module
modparam("exec", "time_to_kill", 200);
modparam("exec", "setvars", 0);

# -- timer module
modparam("timer", "declare_timer", "ON_1MIN_TIMER=ON_1MIN_TIMER,60000,slow,enable");

# -- db_ops module
modparam("db_ops", "declare_handle", "reload")

# -------------------------  request routing logic -------------------

# main routing logic

route{



	# if you have a PSTN gateway just un-comment the follwoing line and 
	# specify the IP address of it to route calls to it
	#$gw_ip = "1.2.3.4"
	# alternatively (even better, set it as global persistent parameter
	# using serweb or ser_attrs); also if using a PSTN GW per-subscriber
	# options must ($gw_acl) or may (asserted_id) be set to enable calls
	# to PSTN; if email-like addresses are used, having a URI alias for
	# processing incoming pstn-2-ip requests may be useful too
	# important: the script is assuming one global pstn-gw for all domains!
	# failure to allow gw_ip to be a domain-specific attribute would result
	# in security gaps (onsend_route checks only for one gateway)


	# first do some initial sanity checks
	route(INIT);

	# bypass the rest of the script for CANCELs if possible
	route(CATCH_CANCEL);

	# check if the request is routed via Route header
	route(LOOSE_ROUTE);

	# look up domain IDs
	route(DOMAIN);

	# answer OPTIONS to our system
	route(OPTIONS_REPLY);

	# enforce domain policy
	route(DOMAIN_POLICY);

	# handle REGISTER requests
	route(REGISTRAR);

	# from here on we want to know who is calling
	route(AUTHENTICATION);

	# we are finished with all the precaution work -- let's
	# try to locate the callee; the first route that matches
	# "wins", if none matches, SER will send a 404

	# check if we should be outbound proxy for a local user
	route(OUTBOUND);

	# redirect in case user dialed a speed dial entry
	route(SPEEDDIAL);

	# place various site-specific routes here
	route(SITE_SPECIFIC);

	# check if the request is for a local user
	route(INBOUND);

	# here you could for example try to do an ENUM lookup before
	# the call gets routed to the PSTN
	#route(ENUM);

	# last resort: if none of the previous route has found
	# the recepient, try PSTN
	route(PSTN);

	# nothing matched, reject it finally
	sl_reply("404", "No route matched");
}

route[FORWARD]
{
	# if this is called from the failure route we need to open a new branch
	if (isflagset(FLAG_FAILUREROUTE)) {
		if (!append_branch()) {
			t_reply("500", "Too many branches");
			drop;
		}
	}

	# if this is an initial INVITE (without a To-tag) we might try another
	# (forwarding or voicemail) target after receiving an error
	if (method=="INVITE" && !@to.tag) {
		t_on_failure("FAILURE_ROUTE");
	}

	# always use the reply route to check for NATed UAS
	t_on_reply("REPLY_ROUTE");

	# insert a Record-Route header into all requests
	# this has to be done as one of the last steps to include all the RR
	# cookies which might have been created during the script run
	route(RR);

	# turn on or off the RTP proxy as the last step because it modifies the SDP
	route(RTPPROXY);


	# remove credentials to keep requests shorter
	if (isflagset(FLAG_AUTH_OK) && !isflagset(FLAG_DONT_RM_CRED) ) {
		consume_credentials();
	}

	# send it out now; use stateful forwarding as it works reliably
	# even for UDP2TCP
	if (!t_relay()) {
		if (isflagset(FLAG_FAILUREROUTE)) {
			# This should be replaced with
			# t_reply_error() similar to sl_reply_error()
			# in order to return the proper failure code.
			t_reply("500", "Request cannot be forwarded");
		} else {
			sl_reply_error();
		}
	}
	drop;
}

route[INIT]
{
	# initial sanity checks -- messages with
	# max_forwards==0, or excessively long requests
	if (!mf_process_maxfwd_header("10")) {
		sl_reply("483","Too Many Hops");
		drop;
	}

	#if (msg:len >=  max_len ) {
	# if (msg:len >=  4096 ) {
	#	sl_reply("513", "Message too big");
 	#		drop;
	#}


	# this flag is need for the onsend route
	if (@to.tag) {
		setflag(FLAG_TOTAG);
	}
	
	# check if the UAC is natted and fix the message appropiatly
	route(NAT_DETECTION);

	# lets account all initial INVITEs
	# further in-dialog requests are accounted by a RR cookie (see below)
	if (method=="INVITE" && !@to.tag) {
		setflag(FLAG_ACC);
	}

	if ($replicate==1) { # if global flag enabled, carry on replication
		setflag(FLAG_REPL_ENABLED);
	}
}

route[OPTIONS_REPLY]
{
	# if it is an OPTIONS without a username in the RURI but one
	# of our IPs answer directly statelessly
	if (method=="OPTIONS" && !@ruri.user && (uri==myself||$t.did)) {
		options_reply();
		drop;
	}
}

route[NAT_DETECTION]
{
	# lots of UAs do not send rport in there Via header
	# so we put it there to remember where to send the reply to
	force_rport();
	force_tcp_alias();

	# check if the request contains hints for a NATed UAC
	# also try to rewrite contacts using maddr; using maddr is a real
	# dubious technique and we better replace such with transport address;
	# downside: it fails for clients fronted by another server, in which
	# case a valid contact we dislike because of maddr will be substituted
	# inapproprietely; (e.g., WM from other domains will fail); if worried
	# about that, remove tests for maddr and recompile SER using HONOR_MADDR
	# also note that possibly rewriting contacts may lead to client
	# denying subseqent requests to them because they don't recognized
	# fixed contacts as their own; we haven't encountered such case
	# yet; a possible solution a la usrloc would be to store the original
	# information as a contact parameter and restore it on its way back
	if (nat_uac_test("19") || (@hf_value["contact"] && @contact.uri.params.maddr) ) {
		setflag(FLAG_NAT);
		$uac_nat=1;
		setavpflag($uac_nat, "dialog_cookie");
		if (method=="REGISTER") {
			# prepare the Contact so that the registrar module saves the
			# source as well
			fix_nated_register();
		} else {
			# overwrite the Contact to allow proper in-dialog routing
			fix_nated_contact();
		}
	}

}

route[RTPPROXY]
{
	# if no NAT is involved we dont have to do here anything
	if (!isflagset(FLAG_NAT)) {
		break;
	}

	# if the message terminates a dialog turn RTP proxy off
	if (method=="BYE" || method=="CANCEL") {
		unforce_rtp_proxy();
		append_hf("P-RTP-Proxy: UNFORCED\r\n");
		break;
	}

	# turn the RTP proxy on for INVITEs and UPDATEs
	if (((method=="INVITE" || method == "UPDATE") && @msg.body)  && !isflagset(FLAG_RTP_PROXY)) {
		force_rtp_proxy('r');
		append_hf("P-RTP-Proxy: YES\r\n");
		setflag(FLAG_RTP_PROXY);
	}
}

route[LOOSE_ROUTE]
{
	# subsequent messages withing a dialog should take the
	# path determined by the Route header
	if (loose_route()) {
		# mark routing logic in request
		append_hf("P-hint: rr-enforced\r\n"); 

		# if the Route contained the accounting AVP cookie we
		# set the accounting flag for the acc_db module.
		# this is more for demonstration purpose as this could
		# also be solved without RR cookies.
		# Note: this means all in-dialog request will show up in the
		# accouting tables, so prepare your accounting software for this ;-)
		if ($account == "yes") {
			setflag(FLAG_ACC);
		}

		# restore the NAT flag if present
		if ($uac_nat == 1) {
			setflag(FLAG_NAT);
		}

		# restore Session Timer flag and headers
		if ($stimer && ($stimer != "0")) {
			route(SESSION_TIMER);
		}

		# for broken devices which overwrite their Route's with each
		# (not present) RR from within dialog requests it is better
		# to repeat the RRing
		# and if we call rr after loose_route the AVP cookies are restored
		# automatically :)
		# There is also one scenario where subsequent indialog RR is
		# required if the initial SUBSCRIBE forked.
		# note that here we forward before authentication check is executed;
		# generally we only authenticate dialog-initiating requests; some
		# in-dialog requests can't be authenticated at all, see the
		# call-forwarding example in route[DOMAIN]
		route(RR);

		route(FORWARD);
	}
}

route[RR]
{
	if (!isflagset(FLAG_RR_DONE) && !method=="REGISTER") {
		# we record-route all messages -- to make sure that
		# subsequent messages will go through our proxy; that's
		# particularly good if upstream and downstream entities
		# use different transport protocol

		# if the inital INVITE got the ACC flag store this in
		# an RR AVP cookie. this is more for demonstration purpose
		if (isflagset(FLAG_ACC)) {
			$account = "yes";
			setavpflag($account, "dialog_cookie");
		}

		# let's insert the RR header now
		record_route();

		# this flag simply allows to call this route several times
		# without inserting several RR headers
		setflag(FLAG_RR_DONE);
	}
}

route[DOMAIN]
{
	# check if the caller is from a local domain
	lookup_domain("$fd", "@from.uri.host");

	# check if the callee is at a local domain
	lookup_domain("$td", "@ruri.host");
}

route[DOMAIN_POLICY]
{

	# we dont know the domain of the caller and also not
	# the domain of the callee -> somone uses our proxy as
	# a relay; however we apply this check only to dialog
	# initiating requests (no totag) -- in some cases such
	# as call-forwarding, subsequent requests may not include
	# served domain neither as origination nor destination
	# (a@A calls b@B that forwards to c@C; BYE is formed as
	# BYE a's IP\n f: b@B \n t: a@A; C server doesn't spot
	# C domain anywhere despite BYE is legitimate)
	if (!isflagset(FLAG_TOTAG) && !$t.did && !$f.did) {
		sl_reply("403", "Relaying Forbidden");
		drop;
	}
}



route[REGISTRAR]
{
	# process only REGISTERs here
	if (!method=="REGISTER") {
		break;
	}

	# if this is a replica (sent to multicast address), trust it to be
	# secure and store it in usrloc
	if (dst_ip==224.0.1.75) {
		if (!isflagset(FLAG_REPL_ENABLED)) {
			# multicast replication adminsitratively disabled -- ignore
			drop;
		}
		
		if (search("^Repl-Marker: nated")) { #: read marker from master
			setflag(FLAG_NAT);
			$uac_nat=1;
		}

		# If the replicating server added its own server id to the request
        # then obtain its value and store it in an attribute, this is used
        # by registrar.
        $server_id = @msg.header["SER-Server-ID"];

		# assumes URI in form of UID@mydomain; store contacts under
		# this UID; note it only works if local policy causes UIDs to
		# have form compliant to RFC3261 URI usernames
		$tu.uid=@ruri.user;
		if (!save_mem_nr("location")) {
			log(1, "SER: Error while processing replicated REGISTER");
		}
		drop;
	} else {
	    # This is a REGISTER request received from the UA. Remove our internal
        # header fields if they are present in the request, this may be an
        # attempt of the user to fool us.
        remove_hf("SER-Server-ID");
        remove_hf("Repl-Marker");
    }

	# check if the REGISTER if for one of our local domains
	if (!$t.did) {
		sl_reply("403", "Register forwarding forbidden");
		drop;
	}

	# the REGISTER target is in the To header, so reload the domain
	if (!lookup_domain("$td", "@to.uri.host")) {
		sl_reply("404", "Unknown Domain");
		drop;
	}

	append_to_reply("Expires: 600\r\n");
	# useful for clients that ignore expires in 200 -- this is a try
	# to keep them sticking to our value of 600
	append_to_reply("Min-Expires: 240\r\n");

	# we want only authenticated users to be registered
	if (!www_authenticate("$fd.digest_realm", "credentials")) {
		if ($? == -2) {
			sl_reply("500", "Internal Server Error");
		} else if ($? == -3) {
			sl_reply("400", "Bad Request");
		} else {
			if ($digest_challenge) {
				append_to_reply("%$digest_challenge");
			}
			sl_reply("401", "Unauthorized");
		}
		drop;
	}

	# check if the authenticated user is the same as the target user
	if (!lookup_user("$tu.uid", "@to.uri")) {
		sl_reply("404", "Unknown user in To");
		drop;
	}

	# the authentication ID does not match the ID in the To header
	if ($f.uid != $t.uid) {
		sl_reply("403", "Authentication and To-Header mismatch");
		drop;
	}

	# check if the authenticated user is the same as the request originator
	# you may uncomment it if you care, what uri is in From header
	#if (!lookup_user("$fr.uid", "@from.uri")) {
	#	sl_reply("404", "Unknown user in From");
	#	drop;
	#}
	#if ($fu.uid != $fr.uid) {
	#	sl_reply("403", "Authentication and From-Header mismatch");
	#	drop;
	#}

	# everyhting is fine so lets store the binding
	if (!save_contacts("location")) {
		sl_reply("400", "Invalid REGISTER Request");
		drop;
	}
	if (isflagset(FLAG_REPL_ENABLED)) {
		if (isflagset(FLAG_NAT)) {
			append_hf("Repl-Marker: nated\r\n");
		}
		# Append this server's unique ID to the request
		append_hf_value("SER-Server-ID", "%@sys.server_id");
		# note: we are multicasting a successful REGISTER
		# to all proxies on the multicast network for
		# sake of replication; in case they share the
		# same IP address (VIP) it is important to set
		# the sending IP address to an unshared one
		# (in the future a special mcast module may 
		# use unbound sockets for sending and leave
		# the source IP address decision up to kernel
		# routing tables)
		#DEBCONF-REPL_SEND_ADDR-START
		force_send_socket(udp:127.0.0.1);
		#DEBCONF-REPL_SEND_ADDR-END
		# put UID in request URI so that it doesn't
		# have to be looked up by all multicast receivers
		# in database
		attr2uri("$tu.uid","user");
		forward_udp(224.0.1.75,5060);
	}
	drop;
}



# authentication of request originators claiming to belong to our
# domain
route[AUTHENTICATION]
{
	if (method=="CANCEL" || method=="ACK") {
		# you are not allowed to challenge these methods
		break;
	}


	# requests from non-local to local domains should be permitted
	# remove this if you want a walled garden
	if (! $f.did) {
		break;
	}

	# as gateways are usually not able to authenticate for their
	# requests you will have trust them base on some other information
	# like the source IP address. WARNING: if at all this is only safe
	# in a local network!!!
	if (@src.ip == $gw_ip) {
		break;
	}

	if (!proxy_authenticate("$fd.digest_realm", "credentials")) {
		if ($? == -2) {
			sl_reply("500", "Internal Server Error");
		} else if ($? == -3) {
			sl_reply("400", "Bad Request");
		} else {
			if ($digest_challenge) {
				append_to_reply("%$digest_challenge");
			}
			sl_reply("407", "Proxy Authentication Required");
		}
		drop;
	}

	# check if the UID from the authentication matches the From header
	if (!lookup_user("$fr.uid", "@from.uri")) {
		sl_reply("403", "Fake Identity");
		drop;
	}
	if ($fu.uid != $fr.uid) {
		sl_reply("403", "Fake Identity");
		drop;
	}
	setflag(FLAG_AUTH_OK);
	# load the user AVPs (preferences) of the caller, e.g. for RPID header
	load_attrs("$fu", "$f.uid");
}

route[OUTBOUND]
{
	# if a local user calls to a foreign domain we play outbound proxy for him
	# comment this out if you want a walled garden
	if ($f.did && ! $t.did) {
		append_hf("P-hint: outbound\r\n");
		route(FORWARD);
	}
}

route[SPEEDDIAL]
{
	# if the caller is local and used only two digits
	# we redirect the UA to the real target
	if ($fd.did && uri=~"sip:[0-9][0-9]@") {
		if (sd_lookup("speed_dial")) {
			sl_reply("302", "Speed Dial Redirect");
		} else {
			sl_reply("404", "Speed Dial Not Found");
		}
		drop;
	}
	;
}

route[INBOUND]
{
	# lets see if know the callee
	if (!lookup_user("$tu.uid", "@ruri")) 
		break;
	
	# load the preferences of the callee to have his timeout values loaded
	load_attrs("$tu", "$t.uid");

	# if you want to know if the callee username was an alias
	# check it like this
	#if (! $tu.uri_canonical) {
		# if the alias URI has different AVPs/preferences
		# you can load them into the URI track like this
		#load_attrs("$tr", "@ruri");
	#}

	# check for call forwarding of the callee
	# Note: the forwarding target has to be full routable URI
	#       in this example
	if ($tu.fwd_always_target) {
		attr2uri("$tu.fwd_always_target");

		# if we are forwarding to ourselves, don't
		# remove credentials ; otherwise we would be
		# challenged again
		# Note: this doesn't apply to failure_route which
		# may be still problematic -- credentials are already
		# removed when we forward; consider 3xx!!!
		lookup_domain("$td", "@ruri.host");
		if ($t.did) {
			setflag(FLAG_DONT_RM_CRED);
		}

		route(FORWARD);
	}

	# native SIP destinations are handled using our USRLOC DB
	if (lookup_contacts("location")) {
		append_hf("P-hint: usrloc applied\r\n");


		# we set the TM module timers according to the prefences
		# of the callee (avoid too long ringing of his phones)
		# Note1: timer values have to be in ms now!
		# Note2: this makes even more sense if you switch to a voicemail
		#        from the FAILURE_ROUTE below
		if ($t.fr_inv_timer) {
			if ($t.fr_timer) {
				t_set_fr("$t.fr_inv_timer", "$t.fr_timer");
			} else {
				t_set_fr("$t.fr_inv_timer");
			}
		}

		# this enables session timer support as long as one side supports it.
		# if you want to have session timmer support only for calls from your
		# PSTN gateway but between pure VoIP calls you can remove the comment
		# marks from the if clause in the next line and closing bracket below
		# WARNING: if at all you should trust IP addresses only in your local network!!!
		#if (@src.ip == $gw_ip) {
			route(SESSION_TIMER);
		#}

		route(FORWARD);
	} else {
		sl_reply("480", "User temporarily not available");
		drop;
	}
}

route[PSTN]
{
	# Only if the AVP 'gw_ip' is set and the request URI contains
	# only a number we consider sending this to the PSTN GW.
	# Only users from a local domain are permitted to make calls.
	# Additionally you might want to check the acl AVP to verify
	# that the user is allowed to make such expensives calls.
	if (!$f.did) break;
	if (!$gw_ip) break;
	if (!uri=~"sips?:\+?[0-9]{3,18}@.*") break;
	
	# probably you need to convert the number in the request
	# URI according to the requirements of your gateway here

	# ....

	# check permissions of the caller here for dialog-initiating requests
	if (method=="INVITE" && !@to.tag) {
		if (!$f.gw_acl=="1") {
			sl_reply("403", "pstn not permitted");
			drop;
		}
	}

	# if an optional AVP 'asserted_id' is set we insert an RPID header
	if ($asserted_id) {
		xlset_attr("$rpidheader", "<sip:%$asserted_id@%@ruri.host>;screen=yes");
		replace_attr_hf("Remote-Party-ID", "$rpidheader");
	}

	# enable Session Timer support with the GW
	route(SESSION_TIMER);

	# just replace the domain part of the RURI with the
	# value from the AVP and send it out
	attr2uri("$gw_ip", "domain");
	# set the PSTN_ALLOWED flag, checked from onsend_route
	setflag(FLAG_PSTN_ALLOWED);
	route(FORWARD);
}

route[CATCH_CANCEL] {
	# check whether there is a corresponding INVITE to the CANCEL,
	# and bypass the rest of the script if possible

	if (method == CANCEL) {
		# ser 2.1 only
		if (!t_relay_cancel()) { # implicit drop if the INVITE was found

			# INVITE was found but some error occurred
			sl_reply("500", "Internal Server Error");
			drop;
		}
		# bad luck, no corresponding INVITE was found,
		# we have to continue with the script
		;
	}
}

route[SITE_SPECIFIC] {
	# only if a request is coming for one of our domains...
	if (!$t.did) break;
	# check if we do have some site-specific routing policy
	# such as peering
	# example:
	if (uri=~"^sip:000777") {
		rewritehostport("sems01.iptel.org:5074");
		route(FORWARD);
	}
}

route[SESSION_TIMER]
{
	# we are only interested in session establishment or
	# session refresher
	if (!(method == "INVITE" || method == "UPDATE")) {
		break;
	}

	# lets check if the Session-Expires header is already present
	if (@hf_value.session_expires) {
		# compare the Session-Expires header value with the
		# configured Min-SE
		eval_push("x:%@hf_value.session_expires.uri");
		eval_oper("(int)", -1);
		eval_push("x:%@cfg_get.session_timer.min_se");
		eval_oper("(int)", -1);
		eval_oper(">=", -2);

		# lets check for the Suported header
		if (hf_value_exists("Supported", "timer")) {
			# the UAC supports Session Timer, so we
			# only need to take a look at the values

			if (@eval.pop[-1] == "0") {
				# session interval is lower than the configured Min-SE
				append_to_reply("Min-SE: %@cfg_get.session_timer.min_se\r\n");
				sl_reply("422", "Session Interval Too Small");
				drop;
			}

			# we store the session expires value for the reply route
			$stimer = @hf_value.session_expires.uri;
			# and mark the AVP to be inserted as RR cookie
			setavpflag($stimer, "dialog_cookie");

			# set the session timer flag that indicates the
			# UAC supports the extension.
			setflag(FLAG_SESSIONTIMER);
		} else {
			#session epxires was already inserted by some other proxy
			if (@eval.pop[-1] == "0") {
				# session interval is lower than the configured Min-SE.
				# There is no point in sending 422 response, because the UAC
				# does not support the extension, the values can be corrected instead.
				assign_hf_value("Session-Expires", "%@cfg_get.session_timer.min_se");
				remove_hf_value("Min-SE");
				append_hf_value("Min-SE", "%@cfg_get.session_timer.min_se");
			}
		}
	} else {
		# no Session Timer is requested yet, neither by UAC nor by proxy

		if (@cfg_get.session_timer.default != "0") {
			# Add a Session Expires header
			# to see if the UAS supports Session Timer.
			# We do not insert a Required header because then the
			# call might fail.
			append_hf_value("Session-Expires", "%@cfg_get.session_timer.default");
			if (@cfg_get.session_timer.min_se != "90") { # not the default value
				append_hf_value("Min-SE", "%@cfg_get.session_timer.min_se");
			}

			# mark the AVP to be inserted as RR cookie
			$stimer = @cfg_get.session_timer.default;
			setavpflag($stimer, "dialog_cookie");
		}
	}
}

failure_route[FAILURE_ROUTE]
{
	# mark for the other routes that we are operating from here on from a
	# failure route
	setflag(FLAG_FAILUREROUTE);

	if (t_check_status("486|600")) {
		# if we received a busy and a busy target is set, forward it there
		# Note: again the forwarding target has to be a routeable URI
		# We redirect using 3xx to avoid possible issues with credentials
		# (if we consumed them, they may be missing in a loop, if we don't
		# consume them, messages are bigger and more vulnerable)
		if ($tu.fwd_busy_target) {
			#attr2uri("$tu.fwd_busy_target");
			#route(FORWARD);
			attr_destination("$tu.fwd_busy_target");
			t_reply("302", "Redirect On Busy");
		}
		# alternatively you could forward the request to SEMS/voicemail here
	}
	else if (t_check_status("408|480")) {
		# if we received no answer and the noanswer target is set,
		# forward it there
		# Note: again the target has to be a routeable URI
		if ($tu.fwd_noanswer_target) {
			#attr2uri("$tu.fwd_noanswer_target");
			#route(FORWARD);
			attr_destination("$tu.fwd_noanswer_target");
			t_reply("302", "Redirect On No Answer");
		}
		# alternatively you could forward the request to SEMS/voicemail here
	}
}

onreply_route[REPLY_ROUTE]
{
	# fix Contact in reply if it contains a private IP to allow
	# proper routing of in-dialog messages
	# do the same if the contact is maddred -- see [NAT_DETECTION]
	# for additional notes about it
	if (nat_uac_test("1") || (@hf_value["contact"] && @contact.uri.params.maddr) ) {
		fix_nated_contact();
	}

	# if a NAT is involved and this is the final positive reply
	# which contains a body, start to use the RTP proxy
	if (isflagset(FLAG_RTP_PROXY) &&
		status=~"(18[03])|(2[0-9][0-9])" && @msg.body) {
		force_rtp_proxy('r');
	}

	# lets check for session timer support
	if (isflagset(FLAG_SESSIONTIMER) && status =~ "2[0-9][0-9]") {
		# the UAC wanted to have a session timer

		if (!@hf_value.session_expires) {
			# but the UAS does not support it
			# so we will try to convince the UAC to do it
			append_hf_value("Session-Expires", "%$stimer;refresher=uac");

			if (!hf_value_exists("Require", "timer")) {
				include_hf_value("Require", "timer");
			}
		}
	}
}


onsend_route{
	# bypass check -- eliminate requests to PSTN GW if they have not
	# passed ACL checks (not marked with FLAG_PSTN_ALLOWED) and are
	# dialog-initiating requests (no to-tag, no CANCEL, no ACK); this
	# helps to stop policy bypasses (GW IP uploaded as a forked contact,
	# or a call-forwarding destination, or a DNS name, or a preloaded
	# route, or something else possibly)

	if (to_ip==$g.gw_ip && !isflagset(FLAG_PSTN_ALLOWED) &&
	    !isflagset(FLAG_TOTAG) && method!="ACK" && method!="CANCEL"){
		log(1, "ALERT: non authorized packet for PSTN, dropping...\n%mb\n");
		# can't use advanced features from onsend_route
		#xlog("L_ALERT", "non authorized packet for PSTN, dropping...\n%mb\n");
		drop;
	}
	# RFC1918 relay protection -- useful if SER is attached to an administrative
	# network using private IP address space and you wish to prevent UACs from
	# relaying their packets there
	if (to_ip==10.0.0.0/8 || to_ip==172.16.0.0/12 || to_ip==192.168.0.0/16) {
		log(1, "ALERT: Packet targeted to an RFC1918 address dropped\n");
		drop;
	}

}

route[ON_1MIN_TIMER] {
	# cleanup expired location records
	db_query("delete from location where expires<utc_timestamp()"); # MySQL
	#db_query("delete from location where expires<now()"); # PostgreSQL

	# reload domains if domain table has been changed recently
	# note: because global attributes are read-only and we can't
	# easily remember the "last" status, we check for changed
	# timestamp in 2 minute time-interval

	db_query("select value from global_attrs where name='domain_data_version' and type=0 and cast(value as unsigned int) between unix_timestamp(now())-120 and unix_timestamp(now())", "reload");
	#db_query("select value from global_attrs where name='domain_data_version' and type=0 and cast(value as integer) between date_part('epoch', now() - interval '120 seconds') and date_part('epoch', now())", "reload"); # PostgreSQL

	if (@db.fetch.reload.count=="1") {
		# domain reload only available as fifo command
		exec_msg("sercmd domain.reload"); 
	}
	db_close("reload");
}

